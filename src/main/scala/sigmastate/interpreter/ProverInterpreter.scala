package sigmastate.interpreter

import org.bitbucket.inkytonik.kiama.attribution.AttributionCore
import org.bitbucket.inkytonik.kiama.relation.Tree
import scapi.sigma.rework.{Challenge, DLogProtocol}
import scapi.sigma.rework.DLogProtocol.{DLogInteractiveProver, DLogNode}
import sigmastate._
import sigmastate.utils.Helpers

import scala.util.Try
import org.bitbucket.inkytonik.kiama.rewriting.Rewriter.{everywherebu, everywheretd, rule}
import org.bitbucket.inkytonik.kiama.rewriting.Strategy
import scorex.crypto.hash.Blake2b256
import scorex.utils.Random

/**
  * Proof generated by a prover along with possible context extensions
  */
case class ProverResult[ProofT <: UncheckedTree](proof: ProofT, extension: ContextExtension)

/**
  * Interpreter with enhanced functionality to prove statements.
  *
  */

trait ProverInterpreter extends Interpreter with AttributionCore {
  override type SigmaT = SigmaTree
  override type ProofT = UncheckedTree

  val secrets: Seq[DLogProtocol.DLogProverInput]

  val contextExtenders: Map[Int, ByteArrayLeaf]

  def enrichContext(tree: SigmaStateTree): ContextExtension = {
    val targetName = CustomByteArray.getClass.getSimpleName.replace("$", "")

    val ce = new Tree(tree).nodes.flatMap { n =>
      if (n.productPrefix == targetName) {
        val tag = n.productIterator.next().asInstanceOf[Int]
        contextExtenders.get(tag).map(v => tag -> v)
      } else None
    }.toMap

    ContextExtension(ce)
  }

  /**
    * "Prover steps:
    * *
    * (markSimulated)
    *1. bottom-up: mark every node real or simulated, according to the following rule. DLogNode -- you know the DL,
    * then real, else simulated. COR: if at least one child real, then real; else simulated. CAND: if at least one child
    * simulated, then simulated; else real. Note that all descendants of a simulated node will be later simulated, even
    * if they were marked as real. This is what the next step will do.
    * *
    * Root should end up real according to this rule -- else you won't be able to carry out the proof in the end.
    * *
    * (polishSimulated)
    *2. top-down: mark every child of a simulated node "simulated." If two or more more children of a real COR are real,
    * mark all but one simulated.
    * *
    * (challengeSimulated)
    *3. top-down: compute a challenge for every simulated child of every COR and CAND, according to the following rules.
    * If COR, then every simulated child gets a fresh random challenge. If CAND (which means CAND itself is simulated, and
    * all its children are), then every child gets the same challenge as the CAND.
    * *
    * (simulations)
    *4. bottom-up: For every simulated leaf, simulate a response and a commitment (i.e., second and first prover message)
    * according to the Schnorr simulator. For every real leaf, compute the commitment (i.e., first prover message) according
    * to the Schnorr protocol. For every COR/CAND node, let the commitment be the union (as a set) of commitments below it.
    * *
    *5. Compute the Schnorr challenge as the hash of the commitment of the root (plus other inputs -- probably the tree
    * being proven and the message).
    * *
    * (challengesReal, proving)
    *6. top-down: compute the challenge for every real child of every real COR and CAND, as follows. If COR, then the
    * challenge for the one real child of COR is equal to the XOR of the challenge of COR and the challenges for all the
    * simulated children of COR. If CAND, then the challenge for every real child of CAND is equal to the the challenge of
    * the CAND. Note that simulated CAND and COR have only simulated descendants, so no need to recurse down from them."
    *
    */

  protected def prove(unprovenTree: UnprovenTree, message: Array[Byte]): ProofT = {
    val step1 = markSimulated(unprovenTree).get.asInstanceOf[UnprovenTree]
    val step2 = polishSimulated(step1).get.asInstanceOf[UnprovenTree]
    val step3 = challengeSimulated(step2).get.asInstanceOf[UnprovenTree]
    val step4 = simulations(step3).get.asInstanceOf[UnprovenTree]

    //step 5 - compute root challenge
    val commitments = step4 match {
      case ul: UnprovenLeaf => Seq(ul.commitmentOpt.get)
      case uc: UnprovenConjecture => uc.childrenCommitments
    }

    val rootChallenge = Blake2b256(commitments.map(_.bytes).reduce(_ ++ _) ++ message)

    val step5 = step4.withChallenge(rootChallenge)

    val step6 = proving(step5).get.asInstanceOf[ProofTree]

    convertToUnchecked(step6)
  }

  def prove(exp: SigmaStateTree, context: CTX, message: Array[Byte]): Try[ProverResult[ProofT]] = Try {
    val candidateProp = reduceToCrypto(exp, context).get

    val (cProp, ext) = (candidateProp.isInstanceOf[SigmaT] match {
      case true => (candidateProp, ContextExtension(Map()))
      case false =>
        val extension = enrichContext(candidateProp)
        //todo: no need for full reduction here probably
        (reduceToCrypto(candidateProp, context.withExtension(extension)).get, extension)
    }).ensuring { res =>
      res._1.isInstanceOf[BooleanConstantNode] ||
        res._1.isInstanceOf[CAND] ||
        res._1.isInstanceOf[COR2] ||
        res._1.isInstanceOf[DLogNode]
    }


    ProverResult(cProp match {
      case tree: BooleanConstantNode =>
        tree match {
          case TrueConstantNode => NoProof
          case FalseConstantNode => ???
        }
      case _ =>
        val ct = convertToUnproven(cProp.asInstanceOf[SigmaT])
        prove(ct, message)
    }, ext)
  }

  /**
    * 1. bottom-up: mark every node real or simulated, according to the following rule. DLogNode -- you know the DL,
    * then real, else simulated. COR: if at least one child real, then real; else simulated. CAND: if at least one child
    * simulated, then simulated; else real. Note that all descendants of a simulated node will be later simulated, even
    * if they were marked as real. This is what the next step will do.
    */
  val markSimulated: Strategy = everywherebu(rule[UnprovenTree] {
    case and: CAndUnproven =>
      val simulated = and.children.exists(_.simulated)
      and.copy(simulated = simulated)
    case or: COr2Unproven =>
      val simulated = or.leftChild.simulated && or.rightChild.simulated
      or.copy(simulated = simulated)
    case su: SchnorrUnproven =>
      val secretKnown = secrets.exists(_.publicImage.h == su.proposition.h)
      su.copy(simulated = !secretKnown)
    case _ => ???
  })

  /**
    * 2. top-down: mark every child of a simulated node "simulated." If two or more children of a real COR
    * are real,mark all but one simulated.
    */

  val polishSimulated: Strategy = everywheretd(rule[UnprovenTree] {
    case and: CAndUnproven =>
      if (and.simulated) and.copy(children = and.children.map(_.withSimulated(true)))
      else and
    case or: COr2Unproven =>
      if (or.simulated) {
        or.copy(leftChild = or.leftChild.withSimulated(true), rightChild = or.rightChild.withSimulated(true))
      } else {
        if (or.leftChild.real && or.rightChild.real)
          or.copy(rightChild = or.rightChild.withSimulated(true))
        else or
      }
    case su: SchnorrUnproven => su
    case _ => ???
  })

  /**
    * 3. top-down: compute a challenge for every simulated child of every COR and CAND, according to the following rules.
    * If COR, then every simulated child gets a fresh random challenge. If CAND (which means CAND itself is simulated, and
    * all its children are), then every child gets the same challenge as the CAND.
    */
  val challengeSimulated: Strategy = everywheretd(rule[UnprovenTree] {
    case and: CAndUnproven if and.simulated =>
      assert(and.challengeOpt.isDefined)
      val challenge = and.challengeOpt.get
      and.copy(children = and.children.map(_.withChallenge(challenge)))

    case or: COr2Unproven =>
      val lc = if (or.leftChild.simulated) or.leftChild.withChallenge(Random.randomBytes()) else or.leftChild
      val rc = if (or.rightChild.simulated) or.rightChild.withChallenge(Random.randomBytes()) else or.rightChild
      or.copy(leftChild = lc, rightChild = rc)
    case su: SchnorrUnproven => su
    case _ => ???
  })

  /**
    * 4. bottom-up: For every simulated leaf, simulate a response and a commitment (i.e., second and first prover
    * message) according to the Schnorr simulator. For every real leaf, compute the commitment (i.e., first prover
    * message) according to the Schnorr protocol. For every COR/CAND node, let the commitment be the union (as a set)
    * of commitments below it.
    */
  val simulations: Strategy = everywherebu(rule[ProofTree] {
    case and: CAndUnproven =>
      val commitments = and.children.flatMap {
        case ul: UnprovenLeaf => Seq(ul.commitmentOpt.get)
        case uc: UnprovenConjecture => uc.childrenCommitments
        case _ => ???
      }
      and.copy(childrenCommitments = commitments)

    case or: COr2Unproven =>
      val commitments = Seq(or.leftChild, or.rightChild).flatMap {
        case ul: UnprovenLeaf => Seq(ul.commitmentOpt.get)
        case uc: UnprovenConjecture => uc.childrenCommitments
        case _ => ???
      }
      or.copy(childrenCommitments = commitments)

    case su: SchnorrUnproven =>
      if (su.simulated) {
        assert(su.challengeOpt.isDefined)
        SchnorrSigner(su.proposition, None).prove(su.challengeOpt.get)
      } else {
        val (r, commitment) = DLogInteractiveProver.firstMessage(su.proposition)
        su.copy(commitmentOpt = Some(commitment), randomnessOpt = Some(r))
      }
    case _ => ???
  })

  /**
    * (proving)
    * 6. top-down: compute the challenge for every real child of every real COR and CAND, as follows. If COR, then the
    * challenge for the one real child of COR is equal to the XOR of the challenge of COR and the challenges for all the
    * simulated children of COR. If CAND, then the challenge for every real child of CAND is equal to the the challenge of
    * the CAND. Note that simulated CAND and COR have only simulated descendants, so no need to recurse down from them."
    **/
  val proving: Strategy = everywheretd(rule[ProofTree] {
    case and: CAndUnproven if and.real =>
      assert(and.challengeOpt.isDefined)
      val andChallenge = and.challengeOpt.get
      and.copy(children = and.children.map(_.withChallenge(andChallenge)))

      //CAndUncheckedNode(and.proposition, None, Seq(), and.children)

    case or: COr2Unproven if or.real =>
      assert(or.challengeOpt.isDefined)
      val orChallenge = or.challengeOpt.get
      if (or.leftChild.real)
        or.copy(leftChild = or.leftChild.withChallenge(Helpers.xor(orChallenge, or.rightChild.challengeOpt.get)))
      else
        or.copy(rightChild = or.rightChild.withChallenge(Helpers.xor(orChallenge, or.leftChild.challengeOpt.get)))

      //COr2UncheckedNode(or.proposition, None, Seq(), or.challengeOpt.get, or.leftChild, or.rightChild)

    case su: SchnorrUnproven if su.real =>
      assert(su.challengeOpt.isDefined)
      val privKey = secrets.find(_.publicImage.h == su.proposition.h).get
      val z = DLogInteractiveProver.secondMessage(privKey, su.randomnessOpt.get, Challenge(su.challengeOpt.get))
      SchnorrNode(su.proposition, None, su.challengeOpt.get, z)

    case _ => ???
  })


  //converts SigmaTree => UnprovenTree
  val convertToUnproven: SigmaTree => UnprovenTree = attr {
    case CAND(sigmaTrees) =>
      CAndUnproven(CAND(sigmaTrees), Seq(), None, simulated = false, sigmaTrees.map(convertToUnproven))
    case COR2(left, right) =>
      COr2Unproven(COR2(left, right), Seq(), None, simulated = false, convertToUnproven(left), convertToUnproven(right))
    case ci: DLogNode =>
      SchnorrUnproven(ci, None, None, None, simulated = false)
  }

  //converts ProofTree => UncheckedTree
  val convertToUnchecked: ProofTree => UncheckedTree = attr {
    case and: CAndUnproven =>
      CAndUncheckedNode(and.proposition, None, Seq(), and.children)
    case or: COr2Unproven =>
      COr2UncheckedNode(or.proposition, None, Seq(), or.leftChild, or.rightChild)
    case s: SchnorrNode => s
    case _ => ???
  }


  /*
  val proving: Seq[DLogProtocol.DLogProverInput] => UnprovenTree => UncheckedTree = paramAttr { secrets => {
    case SchnorrUnproven(proposition, commitmentOpt, randomnessOpt, Some(challenge), simulated) =>
      if (simulated) {
        SchnorrSigner(proposition.asInstanceOf[DLogNode], None).prove(challenge)
      } else {
        val privKey = secrets.find(_.publicImage.h == proposition.h).get
        SchnorrSigner.generate(privKey).prove(challenge)
      }

    case CAndUnproven(proposition, childredCommitments, Some(challenge), simulated, children) =>
      val proven = children.map(proving(secrets))
      CAndUncheckedNode(proposition, challenge, proven)

    case COr2Unproven(proposition, childredCommitments, Some(challenge), simulated, leftChild, rightChild) =>
      assert(Helpers.xor(leftChild.challengeOpt.get, rightChild.challengeOpt.get).sameElements(challenge))

      COr2UncheckedNode(proposition, challenge, proving(secrets)(leftChild), proving(secrets)(rightChild))
    case _ => ???
  }}*/
}