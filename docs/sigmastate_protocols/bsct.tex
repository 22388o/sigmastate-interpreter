%\documentclass[11pt]{article}
\documentclass[runningheads]{llncs}
\def\shownotes{1}
\def\notesinmargins{0}

%\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array,xspace}
\usepackage{caption}
\usepackage{subcaption}

\usepackage{amsfonts}
% https://tex.stackexchange.com/questions/11719/how-do-i-backcolor-in-verbatim
\usepackage{xcolor}
\usepackage{alltt}
% Compensate for fbox sep:
\newcommand\Hi[2][lightgray]{%
	\hspace*{-\fboxsep}%
	\colorbox{#1}{#2}%
	\hspace*{-\fboxsep}%
}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\snote}[1]{{\authnote{\textcolor{yellow}{Scalahub notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Morphic}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{brown}{Dima notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{ErgoScript\xspace}
%\newcommand{\mixname}{ZeroJoin\xspace}
\newcommand{\mixname}{ErgoMix\xspace}
%\newcommand{\mixname}{ErgoJoin\xspace}


\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}
\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}

\title{Multi-Stage Contracts In The UTXO Model}

%\title{Protocols in \langname: From Games to Mixers}

%\author{Ergo Developers}


\maketitle


\begin{abstract}
A widely believed tenet in the folklore says that with lack of persistent storage, UTXO model is more limited than account-based smart contracts. While in theory every UTXO blockchain with certain capabilities is able to carry over Turing-complete computations as shown in~\cite{CKM18a}, such results are not practical.
In this work we show how to implement many useful multi-stage contracts with complex and evolving data using UTXO-based models. Some of the examples we present are a Rock-Paper-Scissors game, and an initial coin offering campaign.
\end{abstract}

\section{Introduction}

In Bitcoin, the most popular cryptocurrency, funds are stored in immutable one-time containers protected by a {\em spending condition}, which a spender must satisfy~\cite{Nak08}.
%~\cite{Nak08}. 
This is called the {\em UTXO-based} model, because the containers are called {\em unspent transaction outputs} (UTXOs). As the name suggests, UTXOs are the outputs of a transaction that are not yet spent, and can encode arbitrary conditions as long as they are expressible in the underlying script.
%\footnote{Bitcoin actually discourages such usage of its script, because apart from the few ``standard'' transaction types, a bitcoin core node does not propogate non-standard transactions, even though it accepts a block containing such transactions. Ergo, on the other hand is entirely about non-standard transactions.} 
A transaction in Bitcoin spends (destroys) some UTXOs and creates new ones. %A UTXO is uniquely identified by the transaction id and the output index. Funds stored in a UTXO must be spent in entirety. 

Instead of UTXOs, Ethereum
%~\cite{wood2014ethereum} 
uses the {\em account-based} model, where funds are stored in long-lived accounts (represented by an address) and can be transferred in fractional amounts~\cite{wood2014ethereum}. End users operate an {\em externally owned account}, whose address is (the hash of) a public key. Smart contracts, on the other hand, exist on an address derived from the creating transaction in a deterministic way. A smart contract has methods that can be invoked by sending a message from another address. 
%An Ethereum contract is written in a Turing complete language and 
This model allows contracts to keep a long-lived global state. %This makes Ethereum contracts very powerful. 

Bitcoin also allows smart contracts but its language is highly restrictive compared to Ethereum. Ergo is similar to Bitcoin in that it uses the UTXO model. However, unlike Bitcoin, the scripting language of Ergo (called \langname) is very expressive. In particular, \langname has functional programming and allows us to 
define the spending condition using the inputs and outputs of the spending transaction~\cite{whitepaper}. As shown in~\cite{CKM18a}, \langname does support arbitrary Turing complete computation, albeit very inefficiently via Rule 110 reduction~\cite{NW06}. In this article, we show how to create more efficient and usable contracts with evolving data. The complete code is available at the \langname repository~\cite{langrepo}.%We refer the reader to~\cite{whitepaper} for details about \langname.

%The main structure in \langname is a \emph{box}, which is roughly like a UTXO of Bitcoin. A transaction spends (destroys) some boxes as inputs and creates new boxes (as outputs). A box is made of upto ten {\em registers} labelled $R_0, R_1,\ldots R_9$, four of which are mandatory. $R_0$ contains the monetary value, $R_1$ contains a script with the spending condition, $R_2$ contains assets (tokens) and $R_3$ contains a unique identifier of 34 bytes made up of a transaction ID (32 bytes) and an output index (2 bytes). The spender of a box must provide a `proof' of satisfying its spending condition. 
%
%The proofs are in the form of {\em Sigma-Protocols} (written $\Sigma$-protocols)\cite{Dam10}, which are interleaved with predicates on the transaction and blockchain state. \langname currently supports two such-Protocols defined on a group $G$ of prime order $q$, written here in multiplicative form. 
%%This group is exactly the one defined by the secp256k1 curve of Bitcoin. 
%The first, denoted as \texttt{proveDlog(u)}, is a {\em proof of knowledge of Discrete Logarithm} of some arbitrary group element $u$ with respect to a fixed generator $g$, where the spender proves knowledge of $x$ such that $u = g^x$.
%The second, denoted as \texttt{proveDHTuple(g, h, u, v)}, is a {\em proof of knowledge of Diffie-Hellman Tuple}, i.e., a proof of knowledge of $x$ such that $u = g^x$ and $v = h^x$. %This is derived from Schnorr signatures~\cite{Sch91}. 
%
%The following sections present smart contracts using \langname. More details of \langname are available in the white paper~\cite{whitepaper} and the code for the below examples is available on GitHub~\cite{langrepo}. 

\section{Rock-Paper-Scissors Game}
\label{rps}

Rock-Paper-Scissors (RPS) is a 2-party game, where each party chooses a secret independently of the other and the game is decided after revealing the secrets. 
Let $a, b\in \mathbb{Z}_3$ be the choices of two parties, Alice and Bob, with the understanding that (0, 1, 2) represent (rock, paper, scissors). If $a = b$ then the game is a draw, otherwise if $a-b \in \{1, -2\}$ then Alice wins else Bob wins. 

In an ideal game, both parties reveal their secrets simultaneously, so no party can choose adaptively. In the real-world, however, having the parties reveal their secrets simultaneously is not feasible. Hence, the party that first reveals the secret must be protected from cheating by the second party, something that is often overlooked~\cite{rps15}. The solution for such scenarios is to use {\em commitments}. 
Alice creates a commitment $k=H(a||s)$ to her secret $a$. She uses $k$ and her public key \texttt{alice} to generate \texttt{fullGameScriptHash}, the hash of the following script:
\small{
\begin{verbatim}
val s = getVar[Coll[Byte]](0).get  // Alice's secret byte string s
val a = getVar[Byte](1).get  // Alice's secret choice a (represented as a byte)
val b = SELF.R4[Byte].get    // Bob's public choice b (represented as a byte)
val bob = SELF.R5[SigmaProp].get
val bobDeadline = SELF.R6[Int].get // after this, it becomes Bob's coin
val drawPubKey = SELF.R7[SigmaProp].get
val valid_a = (a == 0 || a == 1 || a == 2) && blake2b256(s ++ Coll(a)) == k
(bob && HEIGHT > bobDeadline) || {valid_a &&
  if (a == b) drawPubKey else {if ((a - b) == 1 || (a - b) == -2) alice else bob}}
\end{verbatim}
}
To start the game, Alice creates a box protected by the script given below:
\small{
\begin{verbatim}
OUTPUTS.forall{(out:Box) =>
  val b             = out.R4[Byte].get
  val bobDeadline   = out.R6[Int].get
  bobDeadline >= HEIGHT+30 && out.value >= SELF.value &&
  (b == 0 || b == 1 || b == 2) && 
  blake2b256(out.propositionBytes) == fullGameScriptHash
} && OUTPUTS.size == 2 && OUTPUTS(0).R7[SigmaProp].get == alice 
\end{verbatim}
}
% // Bob needs to ensure that out.R5 contains bobPubKey

The above code ensures that there must be two outputs, one for each player in the draw case (and going to the same player otherwise). We ignore fee in the above code and refer the reader to Sections~\ref{rps} and~\ref{ico} for code that handles fee. Register $R_7$ of the first output must contain Alice's public key (for use in the draw scenario). Bob has to make sure that $R_7$ of the second output contains his public key. Additionally, he must ensure that $R_5$ of both outputs contains his public key. We don't encode these conditions here because if Bob doesn't follow the protocol, he will lose. If Alice refuses to open her commitment before a certain deadline, then Bob automatically wins. 

\section{Hot-Wallet Contracts: Reversible Addresses}

Our second example describes {\em reversible addresses}, which have anti-theft features in the following sense. 
Any funds sent to a reversible address can only be spent in way that allows payments to be reversed for a certain time. The idea was proposed for Bitcoin and requires a hardfork~\cite{raddress}. In \langname, however, this can be done natively.

To motivate this feature, consider managing the hot-wallet (for instance, of a mining pool). Funds withdrawn by customers originate from this hot-wallet. Being a hot-wallet, its private key is succeptible to compromise, which will lead to funds being stolen. %One day you discover several unauthorized transactions from the hot-wallet, indicating a breach. 
%You wish there was a way to reverse the transactions and cancel the withdraws but alas this is not the case. 
%It is usually impossible to recover the stolen funds once the transaction is mined, even if the breach was discovered within minutes. 
%The irreversibility of fund transfers, usually considered a feature, has now become a bug.
We would like that in the event of such a compromise, we are able to save all funds stored in this wallet and move them to another address, provided that the breach is discovered within a specified time (such as 24 hours) of the first unauthorized withdraw. 

%To achieve this, we require that all coins sent from the hot-wallet (both legitimate and by the attacker)
%have a 24 hour cooling-off period, during which the created boxes can only be spent by a trusted private key that is was selected {\em before} the compromise occurred. This trusted key must be different from the hot-wallet private key and should ideally be in cold storage. 
%After 24 hours, these boxes become `normal' and can only be spent by the receiver.

In \langname, this can done by storing the funds in a special type of address denoted as {\em reversible}. Assume that \texttt{alice} is the public key of the hot-wallet and \texttt{carol} is the public key of the trusted party. Note that the trusted party must be decided at the time of address generation ({\em before} the compromise occurred) and cannot be changed later. To use a different trusted party, a new address has to be generated. Let \texttt{blocksIn24h} be the estimated number of blocks in a 24 hour period. 
%A reversible address is a P2SH address whose script encodes the following conditions:   
%\begin{enumerate}
%	\item This input box can only be spent by \texttt{alice}.
%	\item Any output box created by spending this input box must have in its register $R_5$ a number at least \texttt{blocksIn24h} more than the current height. 
%	\item Any box created by spending this box must be protected by a script requiring the following: 	
%	\begin{enumerate}
%		\item Its register $R_4$ must have an arbitrary public key called \texttt{bob}.
%		\item Its register $R_5$ must have an arbitrary integer called \texttt{bobDeadline}.
%		\item It can only be spent spent by \texttt{carol} if \texttt{HEIGHT $\leq$ bobDeadline}.
%		\item It can only be spent by \texttt{bob} if \texttt{HEIGHT $>$ bobDeadline}.
%	\end{enumerate}  
%\end{enumerate}
%Thus, all funds sent from such addresses have a temporary lock of \texttt{blocksIn24h} blocks. This can be replaced by any other desired value but it must be decided at the time of address generation. 
Let \texttt{bob} be the public key of a customer who is withdrawing. 
%Such addresses are designed for storing large amount of funds for automated withdraws (such as hot-wallets). 
%They are not designed for daily spending (such as paying for a coffee). 
To create a reversible address, first create a script, \texttt{withdrawScript}, with the following code:
\small{
\begin{verbatim}
val bob         = SELF.R4[SigmaProp].get // public key of customer withdrawing
val bobDeadline = SELF.R5[Int].get       // max locking height
(bob && HEIGHT > bobDeadline) || (carol && HEIGHT <= bobDeadline)
\end{verbatim}
}

Let \texttt{feeProposition} be the script paying mining fee and \texttt{maxFee} be the maximum allowed fee. The reversible address is the P2SH address of the following script:
\small{
\begin{verbatim}
val isChange = {(out:Box) => out.propositionBytes == SELF.propositionBytes}
val isWithdraw = {(out:Box) => 
  out.R5[Int].get >= HEIGHT + blocksIn24h && out.propositionBytes == withdrawScript }
val isFee = {(out:Box) => out.propositionBytes == feeProposition}
val isValid = {(out:Box) => isChange(out) || isWithdraw(out) || isFee(out)}
val totalFee = OUTPUTS.fold(0L, {(x:Long, b:Box) => if (isFee(b)) x + b.value else x })
alice && OUTPUTS.forall(isValid) && totalFee <= maxFee
\end{verbatim}
}
%The sender (\texttt{alice}) must ensure that register $R_4$ of the new box contains \texttt{bob}. 
Normally \texttt{bob} will spend the box after roughly \texttt{blocksIn24h} blocks. If an unauthorized transaction from \texttt{alice} is detected, an ``abort procedure'' is triggered by \texttt{carol} and funds in any unspent boxes sent from \texttt{alice} are diverted to a secure address. %Additionally, boxes currently controlled by \texttt{alice} also need to be sent secure addresses. 


\section{An ICO Example}
\label{ico}

We consider an Initial Coin Offering (ICO) for a project wanting to collect at least a certain amount of funds (in Ergs). Once the funding threshold is crossed and funding period ends, the project is kickstarted and tokens are issued proportional to the total funding. The investors can then withdraw the tokens based on their investment amount. % during the funding period. The contract steps are briefly described below with details provided further.

It is not trivial to create an ICO on top of UTXO based currencies, because, in contrast to account-based models, there is no explicit persistent storage here. However, Ergo brings spending transactions into the execution context of scripts. With this small change it becomes possible to express dependencies between transaction outputs and inputs, and create complex systems such as an ICO.%execute arbitrarily complex Turing-complete programs~\cite{CKM18a}. 
%In this article we will define a concrete scenario of a multi-stage contract using an ICO, where we have three stages (funding, token issuance, withdrawal).
%Now imagine an ICO for thousands of participants. 

%\subsection{Overview of the ICO}
%\paragraph{Overview:}
%There could be many possible scenarios associated with an ICO. 
%We consider an ICO that wants to collect at least a certain amount of funds (in Ergs) to start the project. Once the funding threshold is crossed and funding period ends, the project is kickstarted and ICO tokens are issued proportional to the total funding. After this the investors can withdraw ICO tokens based on the amount they had invested. % during the funding period. The contract steps are briefly described below with details provided further.
%\begin{enumerate}
%	\item 
The number of investors may run into thousands, and the naive solution would store this data in the contract, as in ERC20 tokens~\cite{erc20}. 
Unlike Ethereum, Ergo does not allow storing large datasets in a contract (this is done for performance and scalability). Rather, we store only a 40-bytes header of (a key, value) dictionary, that is authenticated like a Merkle tree~\cite{RMCI17}. To access some elements in the dictionary, or to modify it, a spending transaction should provide lookup or modification proofs. This allows a contract to authenticate large datasets using very little storage and memory. 

\textbf{The Funding Stage:} 
The project initiates the ICO by creating a box with the guarding script described below and committed to an empty dictionary of type (investor, balance) in $R_5$, where investor is the hash of a script that will guard the box with the withdrawn tokens (once the funding period ends). 
The first funding transaction spends this box and creates a box with the same script and updated data. Further funding transactions spend the box created from the previous funding transaction. The box checks that it is first input of each funding transaction, which must have other inputs belonging to investors. The investor inputs contain a hash of the withdraw script in register $R_4$. 
The script also checks (via proofs) that hashes and monetary values of the investing inputs are correctly added to the dictionary of the new box, which must be the first of two outputs with the correct amount of Ergs (the second output pays a predefined fee). 
In this stage, which lasts at least till height 2,000, withdraws are not permitted and it is only possible to put Ergs into the project. 
More concretely, the first transaction with height of 2,000 or more should keep the same data but change the output's script as described in the next section. 
The \texttt{nextStageScriptHash} variable contains the hash of the issuance stage script.
\small{\begin{verbatim}
val selfIndexIsZero = INPUTS(0).id == SELF.id
val proof = getVar[Coll[Byte]](1).get
val inputsCount = INPUTS.size
val toAdd = INPUTS.slice(1, inputsCount).map({ (b: Box) =>
  val pk = b.R4[Coll[Byte]].get
  val value = longToByteArray(b.value)
  (pk, value)})
val modifiedTree = SELF.R5[AvlTree].get.insert(toAdd, proof).get
val expectedTree = OUTPUTS(0).R5[AvlTree].get
val properTreeModification = modifiedTree == expectedTree
val outputsCount = OUTPUTS.size == 2
val selfOutputCorrect = 
  if(HEIGHT < 2000) OUTPUTS(0).propositionBytes == SELF.propositionBytes
  else blake2b256(OUTPUTS(0).propositionBytes) == nextStageScriptHash
val feeOutputCorrect = OUTPUTS(1).value <= 1 && OUTPUTS(1).propositionBytes == feeBytes
val outputsCorrect = outputsCount && feeOutputCorrect && selfOutputCorrect
selfIndexIsZero && outputsCorrect && properTreeModification
\end{verbatim}
}
%\subsection{The Issuance Stage}
\textbf{The Issuance Stage:}
This stage has only one spending transaction to get to the next stage (the withdrawal stage). The spending transactions makes the following modifications. Firstly, it changes the list of allowed operations on the dictionary from ``inserts only'' to ``removals only'', as the next stage (withdrawal) is only dealing with removing entries from the dictionary.

Secondly, the contract checks that the proper amount of ICO tokens are issued. In Ergo, it is allowed to issue one new kind of token per transaction, and the identifier of the token should be equal to the (unique) identifier of the first input box. The issuance sub-contract checks that a new token has been issued, and the amount of it is equal to the amount of nanoErgs collected by the ICO at till now. Thirdly, the contract checks that a spending transaction is indeed re-creating the box with the guard script corresponding to the next stage, the withdrawal stage.

Finally, the project should withdraw collected Ergs, and of course, each spending transaction should pay a fee. Thus, the sub-contract checks that the spending transaction has indeed 3 outputs (one each for the project tokens box, the Ergs wirhdrawal box, and the fee box), and that the first output and output is carrying the tokens issued. As we do not specify project money withdrawal details, we require a project signature on the spending transaction.
\small{
\begin{verbatim}
val openTree = SELF.R5[AvlTree].get
val closedTree = OUTPUTS(0).R5[AvlTree].get
val digestPreserved = openTree.digest == closedTree.digest
val keyLengthPreserved = openTree.keyLength == closedTree.keyLength
val valueLengthPreserved = openTree.valueLengthOpt == closedTree.valueLengthOpt
val treeIsClosed = closedTree.enabledOperations == 4
val tokenId: Coll[Byte] = INPUTS(0).id
val tokensIssued = OUTPUTS(0).tokens(0)._2
val outputsCountCorrect = OUTPUTS.size == 3
val secondOutputNoTokens = OUTPUTS(0).tokens.size == 1 && 
                           OUTPUTS(1).tokens.size == 0 && 
                           OUTPUTS(2).tokens.size == 0
val correctTokensIssued = SELF.value == tokensIssued
val correctTokenId = OUTPUTS(0).R4[Coll[Byte]].get == tokenId &&
                     OUTPUTS(0).tokens(0)._1 == tokenId
val valuePreserved = outputsCountCorrect && secondOutputNoTokens && 
                     correctTokensIssued && correctTokenId
val stateChanged = blake2b256(OUTPUTS(0).propositionBytes) == nextStageScriptHash
val treeIsCorrect = digestPreserved && valueLengthPreserved && 
                    keyLengthPreserved && treeIsClosed
projectPubKey && treeIsCorrect && valuePreserved && stateChanged
\end{verbatim}
}
%\subsection{The Withdrawal Stage}

\textbf{The Withdrawal Stage:}
Investors are now allowed to withdraw ICO tokens protected by a guard script whose hash is stored in the dictionary. Withdraw is done in batches of size $N$. A withdrawing transaction, thus, has $N + 2$ outputs, where the first output carrys over the withdrawal sub-contract and balance tokens, the last output pays the fee and the remaining $N$ outputs have guarding scripts and token values according to the dictionary. The contract requires two proofs for the dictionary elements: one proving that values to be withdrawn are indeed in the dictionary, and the second proving that the resulting dictionary does not have the withdrawn values. 
%The sub-contract is below.
\small{
\begin{verbatim}
val removeProof = getVar[Coll[Byte]](2).get
val lookupProof = getVar[Coll[Byte]](3).get
val withdrawIndexes = getVar[Coll[Int]](4).get
val out0 = OUTPUTS(0)
val tokenId: Coll[Byte] = SELF.R4[Coll[Byte]].get
val withdrawals = withdrawIndexes.map({(idx: Int) =>
  val b = OUTPUTS(idx)
  if(b.tokens(0)._1 == tokenId) (blake2b256(b.propositionBytes), b.tokens(0)._2)
  else (blake2b256(b.propositionBytes), 0L)})
val withdrawValues = withdrawals.map({(t: (Coll[Byte], Long)) => t._2})
val withdrawTotal = withdrawValues.fold(0L, { (l1: Long, l2: Long) => l1 + l2 })
val toRemove = withdrawals.map({(t: (Coll[Byte], Long)) => t._1})
val initialTree = SELF.R5[AvlTree].get
val removedValues = initialTree.getMany(toRemove, lookupProof).map(
  {(o: Option[Coll[Byte]]) => byteArrayToLong(o.get)})
val valuesCorrect = removedValues == withdrawValues
val modifiedTree = initialTree.remove(toRemove, removeProof).get
val expectedTree = out0.R5[AvlTree].get
val selfTokensCorrect = SELF.tokens(0)._1 == tokenId
val selfOutTokensAmount = SELF.tokens(0)._2
val soutTokensCorrect = out0.tokens(0)._1 == tokenId
val soutTokensAmount = out0.tokens(0)._2
val tokensPreserved = selfTokensCorrect && soutTokensCorrect && 
                      soutTokensAmount + withdrawTotal == selfOutTokensAmount
val properTreeModification = modifiedTree == expectedTree
val selfOutputCorrect = out0.propositionBytes == SELF.propositionBytes
properTreeModification && valuesCorrect && selfOutputCorrect && tokensPreserved
\end{verbatim}
}
%\subsection{Possible Enhancements}

%Please note that there are many nuances our example contract is ignoring. For example, anyone listening to the blockchain is allowed to execute the contract and construct proper spending transactions during funding and withdrawal stages. In the real-world, additional signature from the project or a trusted arbiter may be used.

%Also, there is no self-destruction case considered in the withdrawal contract, so it will live until being destroyed by miners via storage rent mechanism, potentially for decades or even centuries. For the funding stage, it would be reasonable to have an additional input from the project with the value equal to the value of the fee output. And so on.

\section{Conclusion}

This article gave examples of how \langname can be used to create complex contracts as in Ethereum, despite having UTXO based model. We described the following contracts: (1) {\em Reversible Addresses} that have anti-theft features and can be used for running the hot-wallets of an exchange or mining pool. (2) A Rock-Papers-Scissors game similar to the one used in Ethereum tutorials. (3) A full features ICO contract that accepts funding in Ergs and has all the features found in Ethereum examples.

\bibliographystyle{unsrt}
\bibliography{sigmastate_protocols}
\end{document}