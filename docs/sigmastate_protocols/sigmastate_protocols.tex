\documentclass[11pt]{article}

\def\shownotes{1}
\def\notesinmargins{0}

\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array,xspace}

\usepackage{amsfonts}
% https://tex.stackexchange.com/questions/11719/how-do-i-backcolor-in-verbatim
\usepackage{xcolor}
\usepackage{alltt}
% Compensate for fbox sep:
\newcommand\Hi[2][lightgray]{%
	\hspace*{-\fboxsep}%
	\colorbox{#1}{#2}%
	\hspace*{-\fboxsep}%
}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\snote}[1]{{\authnote{\textcolor{yellow}{Scalahub notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Morphic}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{brown}{Dima notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{ErgoScript\xspace}
\newcommand{\mixname}{ErgoMix\xspace}

\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}
\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}

\title{Advanced Tutorial of \langname}

%\title{Protocols in \langname: From Games to Mixers}

\author{authors}


\maketitle


\begin{abstract}
%This article describes \langname via examples. 
Ergo is a smart contract platform based on Bitcoin's UTXO model and Ethereum-like functionality that it provides via a language called \langname. The syntax of \langname is a subset of Scala's. In this article, we give a high-level overview of \langname using examples.

% Note that certain contracts of \langname  (such as \mixname in Section~\ref{mix}) cannot be easily ported to Ethereum due to its account-based model (as opposed to UTXOs)


We use \langname to create smart contracts for several protocols such as an XOR game, a rock-paper-scissors game, {\em reversible addresses} that have anti-theft features, and {\em \mixname}, a non-interactive variant of CoinJoin that enhances transaction privacy. 

%We create several protocols using \langname, such as games and mixing protocols. 
\end{abstract}

\section{Introduction}

\ignore{
\subsection{$\Sigma$-Protocols}
\label{intro:sigma}

The classic example of a $\Sigma$-protocol is the Schnorr identification scheme~\cite{Sch91}. Let $G$ be a cyclic multiplicative group of prime order $q$ and $g$ a generator of $G$. Assume that computing discrete logarithms in $G$ is hard. Alice has a secret $x \in \mathbb{Z}_q$, which she wants to prove knowledge of to some Bob who knows $u = g^x$.

\begin{enumerate}
	\item \textbf{Commit:} Alice selects a random $r$, computes $t = g^r$ and sends $t$ to Bob.
	\item \textbf{Challenge:} Bob selects a random $c\in\mathbb{Z}_q$ and sends $c$ to Alice.
	\item \textbf{Response:} Alice computes $z = r + cx$ and sends $z$ to Bob. Bob accepts iff $g^z = t\cdot u^c$.
\end{enumerate}

The above protocol is a proof of knowledge because Bob can extract $x$ if he can get Alice to respond twice for the same $r$ and different $c$. As an example, for $c = 1, 2$, Bob can obtain $r+x$ and $r+2x$, the difference of which gives $x$. This is also called (special) soundness. The above protocol is also (honest verifier) zero-knowledge because anyone can impersonate Alice if the challenge $c$ of Step 2 is known in advance, simply by picking random $z \in\mathbb{Z}_q$ and computing $t = g^z/u^c$. The statement ``I know the discrete log of $u$ to base $g$'' is called the {\em proposition}, which we denote by $\tau$.

Any protocol that has the above 3-move structure (Alice $\stackrel{t}{\rightarrow}$ Bob, Bob $\stackrel{c}{\rightarrow}$ Alice, Alice $\stackrel{z}{\rightarrow}$ Bob), along with zero-knowledge and soundness property is called a $\Sigma$-protocol. 

\subsection{$\Sigma$-Proofs}
For any $\Sigma$-protocol with messages $(t, c, z)$, we can apply the Fiat-Shamir transform~\cite{fiatshamir} to convert it into a non-interactive one by replacing the role of Bob in Step 2 by any hash function $H$ and computing $c$ = $H(t)$. The resulting protocol with messages $(t, H(t), z)$ can be performed by Alice alone. Intuitively, since $c$ depends deterministically on $t$, Bob cannot ``rewind'' Alice and get two different responses for the same $r$. Additionally, Alice cannot know $c$ in advance before deciding $t$ if $H$ behaves like a random oracle. We call such a non-interactive proof a {\em $\Sigma$-proof}~\cite{Cra96} .

Conceptually, $\Sigma$-proofs are generalizations of digital signatures~\cite{CL06}.
In fact, Schnorr signature scheme~\cite{Sch91} (whose more recent version is popularly known as EdDSA \cite{BDLSY12,rfc8032}) is a special case of the above identification protocol with $c = H(t \Vert m)$, where $m$ is the message. The signature proves that the recipient knows the discrete logarithm of the public key (the proof is attached to a specific message, such as a particular transaction, and thus becomes a signature on the message; all $\Sigma$-proofs described here are attached to specific messages). $\Sigma$-proofs exist for proving a variety of properties and, importantly for \langname, elementary $\Sigma$-proofs can be combined into more sophisticated ones using the techniques of \cite{CDS94}. 
}

%\section{Overview of \langname}
 
\ignore{
Although \langname uses $\Sigma$-protocols, it does so transparently and developers are not required to understand them. 
Here we briefly describe \langname ``under the hood'' -- how it works and what primitives it uses.


\subsection{Complex $\Sigma$-Protocols}

Any two $\Sigma$-protocols of propositions $\tau_0, \tau_1$ with messages $(t_0, c_0, z_0), (t_1, c_1, z_1)$ respectively can be combined into a $\Sigma$-protocol of $\tau_0 \land \tau_1$ with messages $(t, c, z) = (t_0\Vert t_1,c_0\Vert c_1, c_0\Vert c_1)$. We call such a construction an $\andnode$ operator on the protocols. 
More interestingly, as shown in \cite{CDS94},the two protocols can also be used to construct a $\Sigma$-protocol for $\tau_0\lor \tau_1$, where Alice proves knowledge of the witness of one proposition, without revealing which. Let $b\in \{0, 1\}$ be the bit such that Alice knows the witness for $\tau_b$ but not for $\tau_{1-b}$. Alice will run the correct protocol for $\tau_b$ and a simulation for $\tau_{1-b}$. First she generates a random challenge $c_{1-b}$. She then generates $(t_{1-b}, z_{1-b})$ by using the simulator on $c_{1-b}$. She also generates $t_b$ by following the protocol correctly. The pair $(t_0, t_1)$ is sent to Bob, who responds with a challenge $c$. Alice then computes $c_b = c\oplus c_{1-b}$. She computes $z_b$ using $(t_b, c_b)$. Her response to Bob is $((z_0, c_0), (z_1, c_1))$, who accepts if: (1) $c = c_0 \oplus c_1$ and (2) $(t_0, c_0, z_0), (t_1, c_1, z_1)$ are both accepting convesations for $\tau_0, \tau_1$ respectively. We call such a construction an $\ornode$ operator. 

Clearly, both the $\andnode$ and $\ornode$ operators also result in $\Sigma$-protocols that can be further combined or made non-interactive via the Fiat-Shamir transform. 

There is one more operator that we need called $\tnode$, which allows us to construct a $k$-out-of-$n$ $\Sigma$-protocol~\cite{CDS94} as follows. Given $n$ propositions, Alice can prove knowledge of witnesses for at least $k$ propositions without revealing which. 

\langname gives the ability to build more sophisticated $\Sigma$-protocols using the connectives $\andnode$, $\ornode$, and $\tnode$. 
Crucially, the proof for an $\ornode$ and a $\tnode$ connective does not reveal which of the relevant values the prover knows. For example, in \langname a ring signature by public keys $u_1, \dots, u_n$ can be specified as an $\ornode$ of $\Sigma$-protocols for proving knowledge of discrete logarithms of $u_1, \dots, u_n$. The proof can be constructed with the knowledge of just one such discrete logarithm, and does not reveal which one was used in its construction. 

\subsection{Other Features of \langname} 
}

A key feature of \langname is the use of {\em Sigma-Protocols} (written $\Sigma$-protocols)\cite{Dam10} interleaved with predicates on the transaction and the blockchain state. \langname currently supports two such-Protocols defined on a group $G$ of prime order $q$, written here in multiplicative form. 
%This group is exactly the one defined by the secp256k1 curve of Bitcoin. 
The first, denoted as \texttt{proveDLog(u)}, is a {\em proof of knowledge of Discrete Logarithm} of some arbitrary group element $u$ with respect to a fixed generator $g$, where the spender proves knowledge of $x$ such that $u = g^x$.
This is derived from Schnorr signatures~\cite{Sch91}. The second, denoted as \texttt{proveDHTuple}, is a {\em proof of knowledge of Diffie-Hellman Tuple} and is explained in Section~\ref{mix}.


The main structure in \langname is a \emph{box}, which is roughly like a UTXO of Bitcoin. A transaction spends (destroys) some boxes by using them as inputs and creates new boxes as outputs.  \langname is used to write the {\em spending condition} protecting funds stored in a box. The spender of a box must provide a `proof' of satisfying that condition. 

%A box is made of upto ten {\em registers} labelled $R_0, R_1,\ldots R_9$, four of which are mandatory. $R_0$ contains the monetary value, $R_1$ contains a script with the spending condition, $R_2$ contains assets (tokens) and $R_3$ contains a unique identifier of 34 bytes made up of a transaction ID (32 bytes) and an output index (2 bytes). The other registers can contain any data or be empty (ensuring that no empty register has index lower than a non-empty one).

% Under the hood, \langname is compiled to {\em ErgoTree}, which is what an Ergo node understands. 

%In addition to $\Sigma$-protocols, \langname allows for predicates over the state of the blockchain and the current transaction. These predicates can be combined, via Boolean connectives, with $\Sigma$-statements, and are used during transaction validation. 
%The set of predicates is richer than in Bitcoin, but still lean in order to allow for efficient processing even by light clients. Like in Bitcoin, we allow the use of current height of the blockchain; unlike Bitcoin, we also allow the use of information contained in the spending transaction, such as inputs it is trying to spend and outputs it is trying to create. This feature enables self-replication and sophisticated (even Turing-complete) long-term script behaviour, as described in examples below.


The following sections present \langname examples. The full code corresponding to the snippets below is available at the \langname code repository~\cite{langrepo}. 
\section{Basic Examples: Enhanced Spending Contracts}

The examples below use P2SH address and highlight some limitation of Bitcoin. 

\subsection{Short-lived Unconfirmed Transactions: Paying for Coffee}

Suppose you are paying for coffee using cryptocurrency. You make a payment but it is taking a long time for the transaction to confirm. You decide to pay using cash and leave. However, you are worried that your original payment will eventually confirm and then you will either lose it or have to ask for a refund. In bitcoin, you can try to double spend the transaction, which is not very convenient or sure, even if using {\em replace-by-fee}. \langname has a better solution using {\em timed-payments} so that if the transaction is not confirmed before a certain height, it is no longer valid. Timed-payments require that funds be stored in a {\em timed address}, which is created as follows. 

%Assume \texttt{bob} is the coffee shop public key and Alice is the customer paying for coffee.
Alice uses her public key \texttt{alice} (which is of type \texttt{proveDLog}) to create \texttt{aliceScript}:
\begin{verbatim}
	val aliceScript = proposition{alice && HEIGHT <= getVar[Int](1).get}
\end{verbatim}

Alice's address is computed as: \texttt{val aliceAddress = Pay2SHAddress(aliceScript)}. Any funds deposited to \texttt{aliceAddress} can only be spent if the spending transaction satisfies following:
\begin{enumerate}
	\item Context variable with id 1 of the box being spent must contain an integer, say $i$.
	\item The height at mining should be less than or equal to $i$. 
\end{enumerate}

Observe that if the transaction is not mined before height $i$ then the transaction becomes invalid. When paying at a coffee shop, for example, Alice can set $i$ close to the height $h$ at the time of broadcast, for instance, $i = h + 10$. 
Alice can still send non-timed payments by making $i$ very large. Since the context variables are part of the message in constructing the zero-knowledge proof, a miner cannot change it (to make this transaction valid). 

\subsection{Preventing Theft using Reversible Addresses}

We create a useful primitives called {\em reversible addresses}, which have anti-theft features in the following sense:
any funds sent to a reversible address can only be spent using a {\em reversible transaction}. That is, transactions spending funds from such an address must create outputs that allow funds to be reversed for a certain time. The idea was proposed for Bitcoin~\cite{raddress} (using the moniker {\em R-addresses}) and requires a hardfork. In \langname, however, this can be done natively.

To motivate this feature, consider managing the hot-wallet of a mining pool or an exchange. Funds withdrawn by customers originate from this hot-wallet. Being a hot-wallet, its private is succeptible to compromise. One day you discover several unauthorized transactions from the hot-wallet, indicating a breach. You wish there was a way to reverse the transactions and cancel the withdraws but alas this is not the case. In general there is no way to recover the lost funds once the transaction is mined, even if the breach was discovered within minutes. 
%The irreversibility of fund transfers, usually considered a feature, has now become a bug.

We would like that in the event of such a compromise, we are able to save all funds stored in this wallet and move them to another address, provided that the breach is discovered within a specified time (such as 24 hours) of the first unauthorized withdraw. 

To achieve this, we require that all coins sent from the hot-wallet (both legitimate and by the attacker)
have a 24 hour cooling-off period, during which the created UTXOs are ``locked'' and can only be spent by a trusted private key that is was selected {\em before} the compromise occurred. This trusted key must be different from the hot-wallet private key and should ideally be in cold storage. 
After 24 hours, these UTXOs become `normal' and can only be spent by the receiver.

This is done by storing the hot-wallet funds in a special type of address denoted as {\em reversible}. Assume that \texttt{alice} is the public key of the hot-wallet and \texttt{carol} is the public key of the trusted party. Note that the trusted party must be decided at the time of address generation and cannot be changed later. To use a different trusted party, a new address has to be generated. Let \texttt{blocksIn24h} be the estimated number of blocks in a 24 hour period. A reversible address is a P2SH
%\footnote{As in Bitcoin, a P2SH (Pay to Script Hash) address is created from the hash of a script encoding spending conditions for any UTXOs controlled by that address.} 
address whose script encodes the following conditions:   
\begin{enumerate}
	\item This input box can only be spent by \texttt{alice}.
	\item Any output box created by spending this input box must have in its register $R_5$ a number at least \texttt{blocksIn24h} more than the current height. 
	\item Any output box created by spending this input box must be protected by a script requring the following: 	
	\begin{enumerate}
		\item Its register $R_4$ must have an arbitrary public key called \texttt{bob}.'' 
		\item Its register $R_5$ must have an arbitrary integer called \texttt{bobDeadline}.'' 
		\item It can only be spent spent by \texttt{carol} if \texttt{HEIGHT $\leq$ bobDeadline}.''
		\item It can only be spent by \texttt{bob} if \texttt{HEIGHT $>$ bobDeadline}.''	
	\end{enumerate}  
\end{enumerate}

Thus, all funds sent from such addresses have a temporary lock of \texttt{blocksIn24h} blocks. This can be replaced by any other desired value but it must be decided at the time of address generation. All hot-wallet funds must be stored in and sent from the above safe address only. 

Let \texttt{bob} be the public key of a customer who is withdrawing. The sender (\texttt{alice}) must ensure that register $R_4$ of the created box contains \texttt{bob}. In the normal scenario, \texttt{bob} will be able to spend the box after \texttt{blocksIn24h} blocks (with the exact number depending on \texttt{bobDeadline}). 

If an unauthorized transaction is detected from \texttt{alice}, an ``abort procedure'' is triggered via \texttt{carol}: all funds sent from \texttt{alice} and in the locked state are suspect and need to diverted elsewhere. %Additionally, boxes currently controlled by \texttt{alice} also need to be sent secure addresses. 

Note that such reversible addresses are designed for storing large amount of funds needed for automated withdraws (such as an exchange hot-wallet). They are not designed for daily spending (such as paying for a coffee). 
Such an address is created as follows. First create a hash as follows:
\begin{verbatim}
val hash = blake2b256(proposition{
  val bob         = SELF.R4[SigmaProp].get // public key of customer withdrawing
  val bobDeadline = SELF.R5[Int].get       // max locking height
  (bob && HEIGHT > bobDeadline) || (carol && HEIGHT <= bobDeadline)})
\end{verbatim}

Let \texttt{feePropositionBytes} be the script for a box that pays mining fee and \texttt{maxFee} be the maximum fee allowed in one transaction. 
%Compute \texttt{hash = Blake2b256(withdrawScript)}. 
Create an address:
\begin{verbatim}
val depositAddress = Pay2SHAddress(proposition{
  val isChange = {(out:Box) => out.propositionBytes == SELF.propositionBytes}
  val isWithdraw = {(out:Box) => out.R5[Int].get >= HEIGHT + blocksIn24h &&
                                 blake2b256(out.propositionBytes) == hash}
  val isFee = {out:Box) => out.propositionBytes == feePropositionBytes}
  val isValid = {(out:Box) => isChange(out) || isWithdraw(out) || isFee(out)}
  val fee = OUTPUTS.fold(0L, {(x:Long, b:Box) => if (isFee(b)) x + b.value else x })
  alice && OUTPUTS.forall(isValid) && totalFee <= maxFee})
\end{verbatim}

Any funds sent to \texttt{depositAddress} have to be spent in a reversible way. 

\subsection{Cold-Wallet Contracts}

Assume an address is protected by 2 private keys, corresponding to the public keys \texttt{alice} and \texttt{bob}. For security, we want the following conditions to hold:

\begin{enumerate}
	\item One key can spend at most 1\% or 100 Ergs (whichever is higher) in one day.
	\item If both keys are spending then there are no restrictions. 
\end{enumerate}

Let \texttt{blocksIn24h} be the number of blocks in 24 hours. Instead of hardwiring 1\% and 100 Ergs, we will use the variables \texttt{percent} and \texttt{minSpend} respectively. The address is created as follows:
%Set all these parameters in environment \texttt{env} along with the public keys \texttt{alice} and \texttt{bob} to get a compiled script:
\begin{verbatim}
val address = Pay2SHAddress(proposition{
  val depth = HEIGHT - SELF.creationInfo._1 // number of confirmations
  val start = min(depth, SELF.R4[Int].get) // block at which the period started
  val notExpired = HEIGHT - start <= blocksIn24h // expired if 24 hrs passed
  val min = SELF.R5[Long].get // min Balance needed in this period

  val ours:Long = SELF.value - SELF.value * percent / 100
  val keep = if (ours > minSpend) ours else 0L // topup should keep min >= keep
  val nStart:Int = if (notExpired) start else HEIGHT
  val nMin:Long = if (notExpired) min else keep

  val out = OUTPUTS(0)  
  val valid = INPUTS.size == 1 && out.propositionBytes == SELF.propositionBytes &&
    out.value >= nMin && out.R4[Int].get >= nStart && out.R5[Long].get == nMin})
    
  (alice && bob) || ((alice || bob) && min >= keep && (nMin == 0 || valid))})
\end{verbatim}

Spending from this address is done in periods of 24 hours or more (but never less) such that in any one period, the maximum spendable is a fixed fraction of the amount at the beginning of the period. We do this by requiring the spending transaction to have an output with value greater than the minumum (which is stored in $R_5$) and paying back to the same address. The start of the current period is stored in $R_4$. Both registers are copied to the new output within the same period and get new values for if the current period has expired.


%\subsection{Advanced Cold-Wallet Contracts}
%
%We can extend the 2-party cold-wallet contract by adding a third party and the following conditions:
%
%\begin{enumerate}
%	\item One key can spend at most 1\% or 100 Ergs (whichever is higher) in one day.
%	\item For two keys the amount is 10\% or 1000 Ergs (whichever is higher).
%	\item If all three two keys are spending then there are no restrictions. 
%\end{enumerate}

\subsection{Revenue Sharing Addresses}

Assume that Alice, Bob and Carol agree to share revenue with a 50\%, 30\% and 20\% ratio respectively. The following is a contract that automatically enforces this for any coins sent to it:
%First create a script and compute its hash:
% There may be advantages of storing the public keys in a register rather than hardwiring them to address
%First add the public keys \texttt{alice}, \texttt{bob}  and \texttt{carol} of type \texttt{proveDLog} into the environment \texttt{env}. First create a script. 

%First create an outputScript = 

\begin{verbatim}
val outputScriptHash = blake2b256(proposition{
  val spenders = SELF.R4[Coll[(SigmaProp, Int)]].get
  val pubKey:SigmaProp = spenders(getVar[Int](1).get)._1
  val ratio:Int = spenders(getVar[Int](1).get)._2
  val total = spenders.fold(0, {(accum:Int, s:(SigmaProp, Int)) => accum + s._2})
  val balance = SELF.value - SELF.value / total * ratio
  val remainingSpenders = spenders.filter({(s:(SigmaProp, Int)) => s._1 != pubKey})
  val outSpenders = OUTPUTS(0).R4[Coll[(SigmaProp, Int)]].get
  val validOut = OUTPUTS(0).propositionBytes == SELF.propositionBytes &&
                 OUTPUTS(0).value >= balance && remainingSpenders == outSpenders
  pubKey && (outSpenders.size == 0 || validOut)})

val revenueAddress = P2SHAddress(proposition{
  val spenders = Coll((alice, 50), (bob, 30), (carol, 20))
  val pubKey:SigmaProp = spenders(getVar[Int](1).get)._1
  val ratio:Int = spenders(getVar[Int](1).get)._2
  val balance = SELF.value - SELF.value / 100 * ratio
  val remainingSpenders = spenders.filter({(s:(SigmaProp, Int)) => s._1 != pubKey})
  val outSpenders = OUTPUTS(0).R4[Coll[(SigmaProp, Int)]].get
  val validOut = OUTPUTS(0).propositionBytes == outputScriptHash &&
                 OUTPUTS(0).value >= balance && remainingSpenders == outSpenders
  pubKey && validOut})
\end{verbatim}

Any funds sent to \texttt{revenueAddress} are subject to the conditions mentioned above.

\section{Two-party Protocols}

We focus on two-round, two-party protocols. %That is, protocols with two parties that can be performed in two transactions. 
In the first round, the first party, Alice, initiates the protocol by creating a box  protected by a script encoding the protocol rules. In the second round, the second party, Bob, completes the protocol by spending Alice's box usually with one of his own and creating additional boxes that encode the final state of the protocol. 

All the protocols here allow the first round to be offchain in the sense that Alice's box creation may be deferred until the time Bob actually participates in the protocol. Alice instead sends her box-creation transaction to Bob, who will then publish both transactions at a later time. 
\subsection{The XOR Game}

We describe a simple game called ``Same or Different'' or the XOR game. Alice and Bob both submit a coin each and select a bit independently. If the bits are same, Alice gets both coins, else Bob gets both coins. The game consists of 3 steps. 
\begin{enumerate}
	\item Alice commits to a secret bit $a$ as follows. She selects a random bit-string $s$ and computes her commitment $k = H(s\|a)$ (i.e., hash after concatenating $s$ with $a$).
	
	She creates an unspent box called the {\em half-game output} containing her coin and commitment $k$. This box is protected by a script called the {\em half-game script}  given below. Alice waits for another player to join her game, who will do so by spending her half-game output and creating another box that satisfies the conditions given in the half-game script. Alice can also spend the half-game output herself before anyone joins, effectively aborting the game. 
	
	\item Bob joins Alice's game by picking a random bit $b$ and spending Alice's half-game output to create a new box called the {\em full-game output}. This new box  holds two coins and contains $b$ (in the clear) alongwith Bob's public key in the registers. 
	Note that the full-game output must satisfy the conditions given by the half-game script. In particular, one of the conditions requires that the full-game output must be protected by the {\em full-game script} (given below).
	\item Alice opens $k$ offchain by revealing $s, a$ and wins if $a = b$. The winner spends the full-game output using his/her private key and providing $s$ and $a$ as input to the full-game script.

	If Alice fails to open $k$ within a specified deadline then Bob automatically wins. 
\end{enumerate}

The full-game script encodes the following conditions: The registers $R_4$, $R_5$ and $R_6$ are expected to store Bob's bit $b$, Bob's public key (stored as a \texttt{proveDLog} proposition) and the deadline for Bob's automatic win respectively. The context variables with id 0 and 1 (provided at the time of spending the full-game box) contain $s$ and $a$ required to open Alice's commitnent $k$, which is hardwired alongwith Alice's public key \texttt{alice} into the code to compute \texttt{fullGameScriptHash} 
%Alice compiles the full-game script to get a binary representation of its \langname code: 

\begin{verbatim}
val fullGameScriptHash = Blake2b256(proposition{
  val s     = getVar[Coll[Byte]](0).get // bit string s
  val a     = getVar[Byte](1).get       // bit a (represented as a byte)
  val b     = SELF.R4[Byte].get         // bit b (represented as a byte)
  val bob   = SELF.R5[SigmaProp].get    // Bob's public key
  val bobDeadline = SELF.R6[Int].get
   
  (bob && HEIGHT > bobDeadline) || 
  (blake2b256(s ++ Coll(a)) == k && (alice && a == b || bob && a != b))})

val halfGameScript = proposition{
  val out           = OUTPUTS(0)
  val b             = out.R4[Byte].get
  val bobDeadline   = out.R6[Int].get
  val validBobInput = b == 0 || b == 1

  validBobInput && blake2b256(out.propositionBytes) == fullGameScriptHash &&
  OUTPUTS.size == 1 && bobDeadline >= HEIGHT+30 && out.value >= SELF.value * 2 }
\end{verbatim}

Alice creates her half-game box protected by \texttt{halfGameScript}, which requires that the transaction spending the half-game box must generate exactly one output box with the following properties:

\begin{enumerate}
	\item Its value must be at least twice that of the half-game box.
	\item Its register $R_4$ must contain a byte that is either 0 or 1. This encodes Bob's choice $b$.
	\item Its register $R_6$ must contain an integer that is at least 30 more than the height at which the box is generated. This will correspond to the height at which Bob automatically wins.
	\item It must be protected by a script whose hash equals \texttt{fullGameScriptHash}.
\end{enumerate}
 
The game ensure security and fairness as follows. Since Alice's choice is hidden from Bob when he creates the full-game output, he does not have any advantage in selecting $b$. Secondly, Alice is sure to lose if she commits to a value other than 0 or 1. Finally, if Alice refuses to open her commitment, then Bob is sure to win after the deadline expires. 
\subsection{Rock-Paper-Scissors Game}

Compared to Rock-Paper-Scissors (RPS), the XOR game is simpler (and efficient) because there is no draw condition and for this reason should be prefered in practice. However, it is useful to consider the RPS game as an example of more complex protocols.

Let $a, b\in \mathbb{Z}_3$ be the choices of Alice and Bob, with the understanding that 0, 1 and 2 represent rock, paper and scissors respectively. If $a = b$ then the game is a draw, otherwise Alice wins if $a-b \in \{1, -2\}$ else Bob wins. The game is similar to XOR, except that Bob must now generate two outputs. In the draw case each player gets one output, otherwise the winner gets both. 
As before, Alice's commitment $k=H(a||s)$ and public key \texttt{alice} is hardwired into the code:

\begin{verbatim}
val fullGameScript = proposition{
  val s = getVar[Coll[Byte]](0).get  // Alice's secret byte string s
  val a = getVar[Byte](1).get  // Alice's secret choice a (represented as a byte)
  val b = SELF.R4[Byte].get    // Bob's public choice b (represented as a byte)
  val bob = SELF.R5[SigmaProp].get
  val bobDeadline = SELF.R6[Int].get // after this, it becomes Bob's coin
  val drawPubKey = SELF.R7[SigmaProp].get
  val valid_a = (a == 0 || a == 1 || a == 2) && blake2b256(s ++ Coll(a)) == k

  (bob && HEIGHT > bobDeadline) || {valid_a &&
    if (a == b) drawPubKey
    else { if ((a - b) == 1 || (a - b) == -2) alice else bob }}}
    
val scriptHash = Blake2b256(fullGameScript)
\end{verbatim}

%The code is derived from the XOR game by adding \texttt{drawPubKey}. 
To start the game, Alice creates a box protected by \texttt{halfGameScript} given below

\begin{verbatim}
val halfGameScript = proposition{
  OUTPUTS.forall{(out:Box) =>
    val b             = out.R4[Byte].get
    val bobDeadline   = out.R6[Int].get

    bobDeadline >= HEIGHT+30 && out.value >= SELF.value &&
    (b == 0 || b == 1 || b == 2) && blake2b256(out.propositionBytes) == scriptHash
  } && OUTPUTS.size == 2 && OUTPUTS(0).R7[SigmaProp].get == alice }
\end{verbatim}

% // Bob needs to ensure that out.R5 contains bobPubKey

The above code ensures that register $R_7$ of the first output contains Alice's public key (for the draw scenario). Bob has to make sure that $R_7$ of the second output contains his public key. Additionally, he must ensure that $R_5$ of both outputs contains his public key.

\subsection{\mixname: Non-Interactive CoinJoin}
\label{mix}

We describe \mixname, a non-interactive variant of CoinJoin~\cite{coinjoin}, whose security relies on the hardness of the {\em Decision Diffie-Hellman} (DDH) Problem in $G$. The protocol is motivated from ZeroCoin~\cite{zerocoin} to overcomes some of its limitations (discussed later). It is a multi-stage protocol with each stage consisting of two rounds. In each stage, any two parties, Alice and Bob, can participate without having any interaction. Each stage mixes two coins and provides 50\% anonymity. A coin is successively mixed to increase the anonymity to any desired level (say 99.99999\%). 

\mixname uses a primitive called a {\em Proof of Diffie-Hellman Tuple}, explained below. Let $g, h, u, v$ be public group elements. The prover proves knowledge of $x$ such that $u={g}^x$ and $v={h}^x$. 
	%	This is done by extending the protocol of Section~\ref{intro:sigma} as follows. 
	\begin{enumerate}
		\item The prover picks $r \stackrel{R}{\leftarrow} \mathbb{Z}_q$, computes $(t_0, t_1) = ({g}^r, {h}^r)$ and sends $(t_0, t_1)$ to the verifier.
		\item The verifier picks $c \stackrel{R}{\leftarrow} \mathbb{Z}_q$ and sends $c$ to prover.
		\item The prover sends $z = r + cx$ to the verifier, who accepts if ${g}^z = {t_0}\cdot {u}^c$ and $h^z=t_1\cdot v^c$. % for $b \in \{0,1\}$.
	\end{enumerate}
	We use the non-interactive variant, where $c = H(t_0 \Vert t_1\Vert m)$. We call this \texttt{proveDHTuple}$(g, h, u, v)$.
	%This can also be used in a DDH-easy group. 
	
\subsubsection{The Basic Protocol}
\mixname has a pool, called the {\em Half-Mix} pool (H-pool), which contains coins ready for mixing. The following describes any one stage of the protocol. 
To mix an arbitrary non-H-pool coin $B$ (which could itself be the output of a previous mix), any one of the two actions can be performed:
\begin{enumerate}
	\item Pick a coin $A$ from the H-pool (if it is non-empty) and convert $(A, B)$ to two indistinguisble coins $\{O_A, O_B\}$, each spendable by their respective owner. Note that the original boxes $A, B$ are destroyed. Thus, $A$ is removed from the H-pool. We call this the {\em mix} operation. 
	\item Add coin $B$ to the H-pool and wait for someone to use it in mix. This is the {\em pool} operation.
\end{enumerate}


 Without loss of generality, Alice will pool and Bob will mix. In practice, each coin must go through multiple stages of mix, with the choice of going via pool randomly decided after each mix.

\begin{enumerate}
	\item \textbf{Pool:} To add a coin to the H-pool, Alice picks random generator $g\in G$ and $x\in \mathbb{Z}_q$. Let $u = g^{x}$. Alice creates an output box $A$ containing $(g, u)$ and protected by the script given below. She waits for Bob to join, who will do so by spending $A$ in a transaction as follows: 
	
	\begin{enumerate}
%		\item It has two inputs of equal value, one of which is $A$. %The value of the second input should be the same as in $A$. 
		\item It has two outputs $(O_0, O_1)$ contining tuples $(g, c_1, u, c_2)$ and $(g, c_2, u, c_1)$ respectively. That is, the first and third elements are $g$ and $u$ respectively and the second and fourth elements are swapped. Additionally, their value must be the same as that of $A$.
		\item The spender of $A$ must satisfy $\texttt{proveDHTuple}(g, u, c_1, c_2)\lor \texttt{proveDHTuple}(g, u, c_2, c_1)$.
		\item The outputs should be protected by the script $\tau_\textsf{A} \lor \tau_\textsf{B}$ given in the Mix step below.
	\end{enumerate}
	
	
	\item \textbf{Mix:} Bob randomly picks a Half-Mix box from the H-pool, for instance, $A$. Bob then picks a random secret bit $b \in \mathbb{Z}_2$ and spends $A$ with another of his own unspent box $B$. The spending transaction creates two new unspent boxes $O_0, O_1$ of equal values (and indistinguishable) such that $O_b$ is spendable only by Alice and $O_{1-b}$ is spendable only by Bob. This is done as follows:
	
	\begin{enumerate}
		\item Bob picks secret $y\in \mathbb{Z}_q$. Let $h = {g}^{y}$ and $v = {u}^{y}$.  %Let $c_b = g^y$ and $c_{1-b} = g^{xy}$. Bob 
		The box $O_b$ contains data $(g, h, u, v)$ and $O_{1-b}$ contains $(g, v, u, h)$. If the DDH problem in $G$ is hard, the distributions $(g, {g}^{y}, {g}^{x}, {g}^{xy})$ and 
		$(g, {g}^{xy}, {g}^{x}, {g}^{y})$ are computationally indistinguishable. In other words, without knowledge of $x$ or $y$, one cannot guess $b$ with probability better than $1/2$.
		\item  Let 
		$\tau_\textsf{A}$ be the proposition: ``Parse data as $(g, h, u, v)$ and
		prove knowledge of $x$ such that $u = {g}^{x}$ and ${v} = {h}^{x}$.'' This is encoded as $\texttt{proveDHTuple}(g, h, u, v)$.
		
		\item Let $\tau_{\textsf{B}}$ be the proposition: ``Parse data as $(g, *, *, h)$ and
		prove knowledge of $y$ such that $h = {g}^{y}$.'' 
		%		Observe that $h, v$ have been swapped from $\tau_\textsf{A}$. 
		This is encoded as $\texttt{proveDlog}(h)$, keeping $g$ as the default generator.
		
		\item Each box is protected by the proposition $\tau_\textsf{A} \lor \tau_\textsf{B}$. 
		
	\end{enumerate}

%	\item \textbf{Spend:} Alice and Bob spent their respective boxes using their secrets, possibly sending funds back to the pool or mix stages. Bob already knows which coin belongs to him. For each output, Alice will parse the data as $(g, h, u, v)$ and select the one with $v = h^x$. 
\end{enumerate}
	After the mix, Alice and Bob can spent their respective boxes using their secrets. 
	To identify her box, Alice will parse the data of both boxes as $(g, h, u, v)$ and select the one with $v = h^x$. 

%\subsubsection{Implementing \mixname In \langname}
\paragraph{\langname Code:} Let \texttt{g} be the generator of \texttt{proveDLog}. The following code defines the protocol:
\begin{verbatim}
val fullMixScriptHash = blake2b256(proposition{
  val gX = SELF.R4[GroupElement].get
  val c1 = SELF.R5[GroupElement].get
  val c2 = SELF.R6[GroupElement].get
  proveDlog(c2) || proveDHTuple(g, c1, gX, c2)})

val halfMixScript = proposition{
  val gX = SELF.R4[GroupElement].get
  val c1 = OUTPUTS(0).R5[GroupElement].get
  val c2 = OUTPUTS(0).R6[GroupElement].get

  OUTPUTS(0).value == SELF.value && OUTPUTS(1).value == SELF.value &&
  blake2b256(OUTPUTS(0).propositionBytes) == fullMixScriptHash &&
  blake2b256(OUTPUTS(1).propositionBytes) == fullMixScriptHash &&
  OUTPUTS(0).R4[GroupElement].get == gX && OUTPUTS(1).R4[GroupElement].get == gX &&
  OUTPUTS(1).R5[GroupElement].get == c2 && OUTPUTS(1).R6[GroupElement].get == c1 &&
  (proveDHTuple(g, gX, c1, c2) || proveDHTuple(g, gX, c2, c1))}
\end{verbatim}

Alice's Half-Mix box is protected by \texttt{halfMixScript} given above.
\subsubsection{Analysis Of The Protocol}
\paragraph{Security:} For soundness, observe that if Bob generates the outputs correctly then neither party can spend the other's boxes. Also, Bob cannot generate invalid outputs because he must prove that one of them contains a valid DH tuple, and the other must have two data elements swapped. 

For privacy, observe that any two identical boxes protected by \texttt{halfMixScript} have {\em spender indistinguisbility} because each one is spent using a $\Sigma$-OR-proof that is zero-knowledge~\cite{Dam10}. Our boxes, however, are not identical but rather {\em almost-identical}, where two data elements are swapped. 

%Details below, not needed in tutorial
Denote a box as {\em good} if either it or its almost-identical twin contains a valid DH tuple, and {\em bad} otherwise. Any program $\mathcal{A}$ that distinguishes two almost-identical bad boxes from two good ones can be used to solve DDH. Let $(g, g^x, g^y, a_0, a_1)$ be a given instance of a DDH problem, where we need to decide which of $a_0, a_1$ is $g^{xy}$. 
Then $((g, g^y, g^x, a_0), (g, a_0, g^x, g^y)), ((g, g^y, g^x, a_1), (g, a_1, g^x, g^y))$ forms a valid instance of $\mathcal{A}$'s problem, whose solution is the solution to our DDH instance. 

Any program $\mathcal{B}$ that can distinguish $(g, g^y, g^x, g^{xy})$ from $(g, g^{xy}, g^x, g^y)$ with advantage $\tau > 1/2$ can be used to construct $\mathcal{A}$ with almost the same advantage. $\mathcal{A}$ runs two parallel experiments $E_0, E_1$, each running $n$ copies of $\mathcal{B}$. In copy $i$ of $E_b$, with $b\in\{0, 1\}$, $\mathcal{A}$ selects $r_i \in \mathbb{Z}_q$ to randomize its original problem instance above into a new one by replacing each tuple $(g, c_0, u, c_1)$ by $(g, {c_0}^{r_i}, u, {c_1}^{r_i})$. The left half of the new problem is given to $E_0$ and the right part to $E_1$. Since randomization removes $\mathcal{B}$'s ability to behave in a deterministic manner, any strategy of  $\mathcal{B}$ to cheat is bound to fail in the experiment with bad boxes. Thus, the experiments with good and bad boxes should output 1 roughly $\tau n$ and $n/2$ times respectively, which allows $\mathcal{A}$ to solve its problem. 


\paragraph{Offchain Pool:} The H-Pool can be offchain, so that Alice's Half-Mix box need not be present on the blockchain till the time Bob decides to spend it. Alice sends her unbroadcasted transaction directly to Bob who will broadcast both Half and Full mix transactions at some later time. 

%Can several sequential stages of the protocol be stored offchain? 
%It will be interesting to have a variant of the protocol where several sequential both Alice and Bob add their Half-Mix coins to an offchain H-Pool and a 3rd party combines them without interacting with Alice or Bob. 

\paragraph{Comparing with ZeroCoin:} Both \mixname and ZeroCoin (ZC)~\cite{zerocoin} use an anonymizing pool. The key difference is that the size of our pool depends on the number of unspent Half-Mix boxes, while that of ZC depends on the number of deposits, which is monotonously increasing. 

\paragraph{Fixed Value Coins:} 
For the protocol to work, the output of each mix must have a fixed value, which is carried over to the next stage.
This is fine in theory but implies zero-fee transactions in practice, which is not possible in Ergo. Below we discuss some approaches for handling fee. 

\subsubsection{Handling Fee In \mixname}
Assume that fee is paid in tokens\footnote{Every transaction may generate any quantity of at most one token, whose ID is the box-ID of the first input. For other token-IDs, the sum of quantities in outputs must be less than or equal to the sum of quantities in inputs.} issued by a 3rd party. We call such tokens {\em mixing tokens} and creation of a mixed output consumes one mixing token. A mix transaction (which has two such outputs) consumes exactly two mixing tokens and, to maintain privacy, the balance must be equally distributed between the two outputs. Below are some strategies to ensure fairness in fee payment. 

\begin{enumerate}
	\item \textbf{Perfect Fairness:} 
% This is the A straightforward method of handling fee is as follows. 
 Alice's Half-Mix box contains $i$ mixing tokens and she requires each output box to contain $i-1$ mixing tokens. Thus, Alice can mix her coin $i$ times. 
 
 This optimal fee strategy, however, has two drawbacks. Firstly, it has weakened privacy because it restricts the coins that can be mixed. Secondly, it impacts usability because there may not be boxes with the desired number of tokens. The approximate fairness strategy, discussed next, has better privacy and usability at the cost of reduced fairness.
 
 \item \textbf{Approximate Fairness:} Alice relaxes her condition by requiring that Bob contribute at least one token in the mix. %In the worst case, Alice will have to start with $2^i$ tokens to mix $i$ times. 
 However, 
% To avoid free-loaders, 
she also requires Bob to have {\em initially} started with exactly 1000 tokens in his first mix. Thus, if Bob is contributing, say, 1 token in the current mix, then Alice wants to ensure that he actually got there `the hard way', by starting out with 1000 tokens and losing them in sequential mixes. %, rather than just by starting out with 1. 
%Thus, coins with lower number of mixing tokens should have a higher {\em mix value}. 
%One way to achieve this is via tokens with the following two properties. 
This can be done as follows:

The token issuer restricts the entry of tokens by selling them only in batches of 1000 in a box protected by the script below,
which requires that the tokens can be transferred (as a whole) only if the transaction is either a Full-Mix transaction or creates a Half-Mix box: 
\begin{verbatim}
val halfBox = {(b:Box) => blake2b256(b.propositionBytes) == halfMixScriptHash}
val sameTokenHalfBox = {(b:Box) => halfBox(b) && b.tokens(0) == SELF.tokens(0)}
carol && (halfBox(INPUTS(0)) || sameTokenHalfBox(OUTPUTS(0))) // carol is buyer
\end{verbatim}

The value \texttt{halfMixScriptHash} is a hash of \texttt{halfMixScript}, which has the following additional code: 
\texttt{out.R7[Coll[Byte]].get == blake2b256(SELF.propositionBytes)}, thereby ensuring that $R_7$ of each output contains its hash. The code of \texttt{fullMixScript} is modified:

\begin{verbatim}
val halfMixScriptHash = SELF.R7[Coll[Byte]].get
val halfBox = {(b:Box) => blake2b256(b.propositionBytes) == halfMixScriptHash}
val sameTokenHalfBox = {(b:Box) => halfBox(b) && b.tokens(0) == SELF.tokens(0)}
val noToken = {(token:(Coll[Byte], Long)) => token._1 != SELF.tokens(0)._1}
val noTokenBox = {(b:Box) => b.tokens.forall(noToken)}
val noTokenTx = OUTPUTS.forall(noTokenBox)
(halfBox(INPUTS(0)) || sameTokenHalfBox(OUTPUTS(0)) || noTokenTx) && ...
\end{verbatim}
\item \textbf{First Spender Pays Fee:} Another enhancement, primarily in perfect fairness, is to benefit the party that is willing to wait longer. We then require that the fee for the mix transaction be paid by the first party that spends an output. We can identify the first spender as follows. 

A mix transaction must generate exactly 4 quantities of a token (with some id $x$) distributed equally among 4 outputs. Two of these are the standard mix outputs $O_0, O_1$ with the additional spending condition that one output must contain some non-zero quantity of token $x$. The other two boxes, $O_2, O_3$, have the following identical spending conditions:
\begin{enumerate}
	\item The sum of quantities of token $x$ in the inputs and outputs is 3 and 2 respectively.
	\item One output contains 2 quantities of token $x$ protected by the same script as this box. 
\end{enumerate}

Then it the second spender if and only if there is an input with two quantities of token $x$. 
The mix step will create an additional box with two tokens spendable by the second spender.
\end{enumerate}

% \textbf{Fee Accumulation:} Starting with a fixed number of tokens restricts the number of mixes. To allow arbitrary number of mixes, we suggest a {\em fee accumulation} strategy, where the fee is accumulated rather than paid upfront. %For instance, fee for the mix transaction can be paid when spending the mixed outputs. 	
% The fee keeps accumulating as long as the coin is circulated within the system (i.e., sent back to the H-pool or used in another mix operation) and is paid when the coin exits the system.

%further improvements. Can we reduce offchain data size, do multiple mixes offchain?

%\section{Finite-State Machine in \langname}
\bibliographystyle{unsrt}
\bibliography{sigmastate_protocols}
\end{document}