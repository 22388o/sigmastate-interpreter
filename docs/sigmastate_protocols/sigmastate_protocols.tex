\documentclass[11pt]{article}

\def\shownotes{1}
\def\notesinmargins{0}

\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array,xspace}

\usepackage{amsfonts}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\snote}[1]{{\authnote{\textcolor{yellow}{Scalahub notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Morphic}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{brown}{Dima notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{ErgoScript\xspace}
\newcommand{\mixname}{ErgoMix\xspace}

\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}
\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}

\title{\langname Overview (working title)}

\author{authors}


\maketitle


\begin{abstract}
This paper describes uses \langname to design games and mixing protocols
\end{abstract}
\section{Overview of \langname}

\paragraph{Built-in $\Sigma$-protocols}
Our language incorporates proofs as first-class citizens, giving developers access to cryptographic primitives for non-interactive {\em proofs of knowledge} known as $\Sigma$-protocols (pronounced ``sigma-protocols''). A transaction's output is protected by a statement known as a $\Sigma$-statement. In order to spend the output, the statement needs to be proven true (by providing a $\Sigma$-proof). The combination of the protecting script and the spending proof forms a $\Sigma$-protocol.

\subsection{Sigma Protocols}
For an introduction to $\Sigma$-protocols, we refer the reader to \cite{Dam10} and \cite[Chapter 6]{HL10}. Here we give a brief overview. The classic example of a $\Sigma$-proof is the following 3-step identification protocol due to~\cite{Sch91}. $G$ is a cyclic multiplicative group of prime order $q$ such that computing discrete logarithms in $G$ is hard. Let $g$ be a generator of $G$. Alice has a secret $x \in \mathbb{Z}_q$, which she wants to prove knowledge of to some Bob who knows $y = g^x$.
\begin{enumerate}
	\item \textbf{Commit:} Alice selects a random $r$, computes $u = g^r$ and sends $u$ to Bob.
	\item \textbf{Challenge:} Bob selects a random $c\in\mathbb{Z}_q$ and sends $c$ to Alice.
	\item \textbf{Response:} Alice computes $z = r + cx$ and sends $z$ to Bob. Bob accepts iff $g^z = u\cdot y^c$.
\end{enumerate}

The above protocol is a proof of knowledge because Bob can extract $x$ if he can get Alice to respond twice for the same $r$ and different $c$. As an example, for $c = 1, 2$, Bob can obtain $r+x$ and $r+2x$, the difference of which gives $x$. This is also called (special) soundness. Above protocol is also (honest verifier) zero-knowledge because anyone can impersonate Alice if the challenge $c$ of Step 2 is known in advance simply by computing $z \stackrel{R}{\leftarrow} \mathbb{Z}_q$ and $u = g^z/y^c$. 

Any protocol that has the above 3-move structure (Alice $\stackrel{u}{\rightarrow}$ Bob, Alice $\stackrel{c}{\leftarrow}$ Bob, Alice $\stackrel{z}{\rightarrow}$ Bob), along with zero-knowledge and soundness property for some statement $s$ is called a $\Sigma$-protocol. 

\subsection{Non-Interactive Sigma Protocols}
For any $\Sigma$-protocol of some statement $s$ with messages $(u, c, z)$, we can apply the Fiat-Shamir transform to convert it into a non-interactive proof of $s$ by replacing the role of Bob in Step 2 by any hash function $H$ and computing $c$ = $H(u)$. The resulting protocol with messages $(u, H(u), z)$ can be performed by Alice alone. Intuitively, since $c$ depends deterministically on $u$, Bob cannot ``rewind'' Alice and get two different responses for the same $r$. Additionally, Alice cannot know $c$ in advance before deciding $u$ under the random oracle assumption. 

\subsubsection{Digital Signatures from Sigma Protocols}
\label{digital-sig}
Conceptually, $\Sigma$-proofs \cite{Cra96} are generalizations~\cite{CL06} of digital signatures.
In fact, Schnorr signature scheme~\cite{Sch91} (whose more recent version is popularly known as EdDSA \cite{BDLSY12,rfc8032}) is a special case of the above identification protocol with $c = H(u \Vert m)$, where $m$ is the message. The signature proves that the recipient knows the discrete logarithm of the public key (the proof is attached to a specific message, such as a particular transaction, and thus becomes a signature on the message; all $\Sigma$-proofs described here are attached to specific messages). $\Sigma$-protocols exist for proving a variety of properties and, importantly for \langname, elementary $\Sigma$-protocols can be combined into more sophisticated ones using the techniques of \cite{CDS94}. 

\subsection{Combining Sigma Protocols}

Any two $\Sigma$-protocols of statements $s_0, s_1$ with messages $(u_0, c_0, z_0), (u_1, c_1, z_1)$ respectively can be combined into a $\Sigma$-protocol of $s_0 \land s_1$ with messages $(u, c, z) = (u_0\Vert u_1,c_0\Vert c_1, c_0\Vert c_1)$. We call such a construction an $\andnode$ operator on the protocols. %Such a protocol proves both statements simultaneously. 

More interestingly, as shown in \cite{orprotocol},the two protocols can also be used to construct a $\Sigma$-protocol for $s_0\lor s_1$, where Alice proves knowledge of the witness of one of the statements without revealing which one. Let $b\in \{0, 1\}$ be the bit such that Alice knows the witness for $s_b$ but not for $s_{1-b}$. Alice will run the correct protocol for $s_b$ and a simulation for $s_{1-b}$. First she generates a random challenge $c_{1-b}$. She then generates $(u_{1-b}, z_{1-b})$ by using the simulator on $c_{1-b}$. She also generates $u_b$ by following the protocol correctly. The pair $(u_0, u_1)$ is sent to Bob, who responds with a challenge $c$. Alice then computes $c_b = c\oplus c_{1-b}$. She computes $z_b$ using $(u_b, c_b)$. Her response to Bob is $((z_0, c_0), (z_1, c_1))$, who accepts if: (1) $c = c_0 \oplus c_1$ and (2) $(u_0, c_0, z_0), (u_1, c_1, z_1)$ are both accepting convesations for $s_0, s_1$ respectively. We call such a construction an $\ornode$ operator. 

Clearly, both the $\andnode$ and $\ornode$ operators also result in $\Sigma$-protocols that can be further combined or made non-interactive via the Fiat-Shamir transform. 

There is one more operator that we need called $\tnode$, which allows us to construct a $k$-out-of-$n$ $\Sigma$-protocol in the following sense~\cite{threshold}: given $n$ statements, Alice can prove knowledge of witnesses for at least $k$ statements without revealing which statements were true. 

\snote{Describe Threshold briefly}
\section{Primitives in ErgoScript}

\langname provides as primitives two elementary $\Sigma$-protocols over an elliptic curve group of prime order, written here in multiplicative notation:
\begin{enumerate}
\item A proof of knowledge of discrete logarithm with respect to a fixed group generator: given a group element $y$, the proof convinces a verifier that the prover knows $x$ such that $y=g^x$, where $g$ is the group generator (also known as base point), without revealing $x$. This is the Schnorr signature with public key $y$, described in Section~\ref{digital-sig}.
We call this primtive \texttt{ProveDLog}$(g, y)$.
 
\snote{What is the exact input to the hash function? (what forms the message?)}

\item A proof of equality of discrete logarithms (i.e., a proof of a Diffie-Hellman tuple): given group elements $g_0, y_0, g_1, y_1$, the prover, Alice convinces a verifier Bob that she knows $x$ such that $y_0={g_0}^x$ and $y_1={g_1}^x$, without revealing $x$. This is done as follows. 
\begin{enumerate}
	\item \textbf{Commit:} Alice picks $r \stackrel{R}{\leftarrow} \mathbb{Z}_q$, computes $(u_0, u_1) = ({g_0}^r, {g_1}^r)$ and sends $(u_0, u_1)$ to Bob.
	\item \textbf{Challenge:} Bob picks $c \stackrel{R}{\leftarrow} \mathbb{Z}_q$ and sends $c$ to Alice.
	\item \textbf{Response:} Alice computes $z = r + cx$ and sends $z$ to Bob, who accepts if ${g_b}^z = {u_b}\cdot {y_b}^c$ for $b \in \{0,1\}$.
\end{enumerate}

We use the non-interactive variant of this protocol, where the challenge is computed as $c = H(u_0 \Vert u_1)$. We call this primitive \texttt{ProveDLogEq}$(g_0, y_0, g_1, y_1)$.%This can also be used in a DDH-easy group. 

\snote{What is the exact input to the hash function?}

\end{enumerate}

\langname gives the ability to build more sophisticated $\Sigma$-protocols using the connectives $\andnode$, $\ornode$, and $\tnode$. 
Crucially, the proof for an $\ornode$ and a $\tnode$ connective does not reveal which of the relevant values the prover knows. For example, in \langname a ring signature by public keys $y_1, \dots, y_n$ can be specified as an $\ornode$ of $\Sigma$-protocols for proving knowledge of discrete logarithms of $y_1, \dots, y_n$. The proof can be constructed with the knowledge of just one such discrete logarithm, and does not reveal which one was used in its construction. 

%Our implementation of these protocols is in Scala \cite{scala} and Java \cite{java}. The implementation was informed by SCAPI \cite{scapi}, but does not use SCAPI code. \lnote{our code currently has subdirectories named ``scapi'' so it's hard to say we don't use it\dots} We use Bouncy Castle \cite{bouncycastle} for big integer and elliptic curve operations; the implementation of arithmetic in fields of characteristic 2 (for $\tnode$ connectives) is our own. \lnote{any other credits or background info?}

\paragraph{Rich context, enabling self-replication}
In addition to $\Sigma$-protocols, \langname allows for predicates over the state of the blockchain and the current transaction. These predicates can be combined, via Boolean connectives, with $\Sigma$-statements, and are used during transaction validation. The set of predicates is richer than in Bitcoin, but still lean in order to allow for efficient processing even by light clients. Like in Bitcoin, we allow the use of current height of the blockchain; unlike Bitcoin, we also allow the use of information contained in the spending transaction, such as inputs it is trying to spend and outputs it is trying to create. This feature enables self-replication and sophisticated (even Turing-complete) long-term script behaviour, as described in examples below.

\langname is statically typed (with compile-time type checking) and allows the usual operations, such as integer arithmetic.

\snote{This seems incomplete. In particular, we should describe all context variables and operations allowed, possibly using BNF or some grammar.}


\paragraph{Running time estimation and safety checks}
\lnote{someone should fill this in, because I know very little about it}
See Section \ref{sec:safety} for more details.

\section{\langname Examples}

We give some examples of \langname to illustrate its usage. 
\subsection{The XOR Game}

We describe a simple game called ``Same or different'' or the XOR game. Alice and Bob both submit a coin each and select a bit independently. If the bits are same, Alice gets both coins, else Bob gets both coins. The game requires 3 transactions (steps). 
\begin{enumerate}
	\item Alice commits to a secret bit $a$ as follows. She selects a random bit-string $s$ and computes her commitment $h = H(s\|a)$ (i.e., hash after concatenating $s$ with $a$).
	%Let $x_\textsf{A}\in \mathbb{Z}_q$ be her private key and $y_\textsf{A} = g^{x_\textsf{A}} \in G$ her public key. % We don't need to specify explicitly the keys for now
	
	She creates an unspent box called the {\em half-game output} containing her coin and commitment $h$. This box is protected by a script called the {\em half-game script}  given below. Alice waits for another player to join her game, who will do so by spending her half-game output and creating another box that satisfies the conditions given in the half-game script. Alice can also spend the half-game output herself before anyone joins, effectively aborting the game. 
	
	% We can add a locking period before which Alice cannot spend the box, but this seems unnecessary.

	\item Bob decides to join Alice's game. He generates a random bit $b$ and spends Alice's half-game output alongwith one of his own to create a new box called the {\em full-game output}. This new box  holds two coins and contains $b$ (in the clear) alongwith Bob's public key in the registers. 
	Note that the full-game output must satisfy the conditions given by the half-game script. In particular, one of the conditions requires that the full-game output must be protected by the {\em full-game script} (given below).
	\item Alice opens $h$ by revealing $s, a$. If $a = b$ then Alice wins else Bob wins. The winner spends the full-game output using his/her private key and providing $s$ and $a$ to the full-game script.

	If Alice fails to open $h$ within a specified deadline (say 30 blocks after the full-game output is created) then Bob automatically wins. 
\end{enumerate}

The full-game script encodes the following conditions: The registers \texttt{R4}, \texttt{R5} and \texttt{R6} are expected to store Bob's bit $b$, Bob's public key (stored as a \texttt{ProveDLog} proposition) and the deadline for Bob's automatic win respectively. The context variables with id 0 and 1 (provided at the time of spending the full-game box) contain $s$ and $a$ required to open Alice's commitnent. The remaining part encodes the spending conditon of full-game box. Alice compiles the full-game script to get a binary representation of its \langname code: 

\begin{verbatim}
val fullGameScript = compile("""
{
  val s           = getVar[Coll[Byte]](0).get // bit string s 
  val a           = getVar[Byte](1).get       // bit a (represented as a byte)
  val b           = SELF.R4[Byte].get         // bit b (represented as a byte)
  val bobPubKey   = SELF.R5[SigmaProp].get
  val bobDeadline = SELF.R6[Int].get 
  // after bobDeadline height, Bob can spend unconditionally

  (bobPubKey && HEIGHT > bobDeadline) || {
    blake2b256(s ++ Coll(a)) == h && { // h is Alice's commitment
      alicePubKey && a == b || bobPubKey && a != b
    }
  }
}""")
\end{verbatim}

Then a hash of the above compiled script is computed:

\begin{verbatim}
val fullGameScriptHash = Blake2b256(fullGameScript)
\end{verbatim}

Finally, Alice sets \texttt{fullGameScriptHash} as an environment variable for the compiler and creates her half-game output with the following spending condition:

\begin{verbatim}
alicePubKey || {
  val out           = OUTPUTS(0) // the first output is our 
  val b             = out.R4[Byte].get
  val bobDeadline   = out.R6[Int].get
  val validBobInput = b == 0 || b == 1

  OUTPUTS.size == 1 &&
  bobDeadline >= HEIGHT+30 &&
  out.value >= SELF.value * 2 &&
  validBobInput &&
  blake2b256(out.propositionBytes) == fullGameScriptHash
}
\end{verbatim}

The above script requires that the transaction spending the half-game box must either be signed by Alice or generate exactly one output box with the following properties:

\begin{enumerate}
	\item Its value must be at least twice that of the half-game box.
	\item Register \texttt{R4} must contain a byte that is either 0 or 1. This encodes Bob's choice $b$.
	\item Register \texttt{R6} must contain an integer that is at least 30 more than the height at which the box is generated. This will correspond to the height at which Bob automatically wins.
	\item It must be protected by a script whose hash equals \texttt{fullGameScriptHash}.
\end{enumerate}
 
The game ensure security and fairness as follows. Since Alice's choice is hidden from Bob when he creates the full-game output, he does not have any advantage in selecting $b$. Secondly, Alice is sure to lose if she commits to a value other than 0 or 1. Finally, if Alice refuses to open her commitment, then Bob is sure to win after about 30 blocks. 

%\snote{To do: some explanation about above code}

\subsection{Theft-Proof Addresses}

In this section, we use \langname to design a useful primitive called a {\em reversible address}, which has anti-theft features in the following sense.
Any funds sent to a safe address can only be spent using a {\em reversible transaction}. That is, any transaction spending funds from a safe address must create outputs that allow funds to be reversed for a certain time. 

To motivate this feature, consider managing the hot-wallet of a mining pool or an exchange. Funds withdrawn by customers originate from this hot-wallet. Being a hot-wallet, its private is succeptible to compromise. One day you discover several unauthorized withdraw transactions from the hot-wallet, indicating a breach. You wish there was a way to reverse the transactions and cancel the withdraws but alas this is not the case. In general there is no way to recover the lost funds once the transaction is mined, even if the breach was discovered within minutes. The irreversibility of fund transfers, usually considered a feature, has now become a bug.

We would like that in the event of such a compromise, we are able to save all funds stored in this wallet and move them to another address, provided that the breach is discovered within a specified time (such as 24 hours) of the first unauthorized withdraw. 

To achieve this, we require that all coins sent from the hot-wallet (both legitimate and by the attacker)
have a 24 hour cooling-off period, during which the created UTXOs are ``locked'' and can only be spent by a trusted private key that is was selected {\em before} the compromise occurred. This trusted key must be different from the hot-wallet private key and should ideally be in cold storage. 
After 24 hours, these UTXOs become `normal' and can only be spent by the receiver.

This is done by storing the hot-wallet funds in a special type of address denoted as {\em reversible}. Assume that \texttt{alicePubKey} is the public key of the hot-wallet and \texttt{carolPubKey} is the public key of the trusted party.\footnote{The trusted party must be decided at the time of address generation and cannot be changed later. To use a different trusted party, a new address has to be generated.} A reversible address is a P2SH\footnote{As in Bitcoin, a P2SH (Pay to Script Hash) address is created from the hash of a script encoding spending conditions for any UTXOs controlled by that address.} address whose script encodes the following spending conditions:   
\begin{enumerate}
	\item I can only be spent by \texttt{alicePubKey}.
	\item Any UTXO created by spending me must be protected by a script requring the following: 	
	\begin{enumerate}
		\item ``My register \texttt{R4} contains an arbitrary public key called \texttt{bobPubKey}.'' 
		\item ``My register \texttt{R5} contains an arbitrary integer called \texttt{bobDeadline}.'' 
		\item ``I can only be spent by \texttt{carolPubKey} if blockchain height $\leq$ \texttt{bobDeadline}.''
		\item ``I can only be spent by \texttt{bobPubKey} if blockchain height $>$ \texttt{bobDeadline}.''	
    \end{enumerate}  
	\item Any UTXO created by spending me must satisfy the following: 	
	\begin{enumerate}
		\item Its register \texttt{R5} must contain a number that is at least 100 more than the current height. 
	\end{enumerate}  
\end{enumerate}

Thus, all funds sent from such addresses have a temporary lock of 100 blocks. Note that the number 100 can be replaced by any desired value but it must be decided at the time of address generation. All hot-wallet funds must be stored in and sent from the above safe address only. 

Let \texttt{bobPubKey} be the public key of a customer who is withdrawing. The sender (\texttt{alicePubKey}) must ensure that register \texttt{R4} of the created UTXO contains \texttt{bobPubKey}. In the normal scenario, \texttt{bobPubKey} will be able to spend the UTXO after around 100 blocks. 

If an unauthorized transaction is detected from \texttt{alicePubKey}, an ``abort procedure'' is triggered via \texttt{carolPubKey}: all funds sent from \texttt{alicePubKey} currently in the locked state are suspect and need to diverted elsewhere. Additionally, any UTXOs currently controlled by \texttt{alicePubKey} also need to be sent secure addresses. 

Note that such reversible addresses are designed for storing large amount of funds needed for automated withdraws (such as an exchange hot-wallet). They are not designed for storing funds for personal use (such as paying for a coffee).

Concretely, such an address is created as follows. First create a script and compile it to get its binary version called \texttt{withdrawScript}:
\begin{verbatim}
val withdrawScript = compile("""{
  val bobPubKey   = SELF.R4[SigmaProp].get // public key of customer withdrawing
  val bobDeadline = SELF.R5[Int].get       // max locking height
  (bobPubKey && HEIGHT > bobDeadline) || (carolPubKey && HEIGHT <= bobDeadline)
}""")
\end{verbatim}

Then compute \texttt{withdrawScriptHash = Blake2b256(withdrawScript)} and create a compiled script called \texttt{depositScript} using this hash as follows:

\begin{verbatim}
val depositScript = compile("""{ 
  alicePubKey && OUTPUTS.forall({(out:Box) =>
    out.R5[Int].get >= HEIGHT + 30 &&
    blake2b256(out.propositionBytes) == withdrawScriptHash
  })
}""")
\end{verbatim}

Finally the reversible P2SH address is obtained as:

 \texttt{val depositAddress = Pay2SHAddress(depositScript)}.

\subsection{The Mixing Protocol}

We now describe a mixing protocol for Ergo called \mixname, which is motivated from ZeroCash (ZC). 
%The name \mixname is a portmanteau of {\em Two} and {\em Mix}. 
\mixname essentially mixes two coins and so provides ``50\% anonymity'' in one mix. A coin can be successively mixed to increase the anonymity above any desired level (say 99.99999\%). We do a formal analysis of the protocol later. 

The protocol is as follows:

\begin{enumerate}
	\item \textbf{Pool:} To add a coin to the pool, Alice picks random generator $g_\textsf{A}\in G$ and $x_\textsf{A}\in \mathbb{Z}_q$. Let $y_\textsf{A} = {g_\textsf{A}}^{x_\textsf{A}}$. Alice creates an output box $A$ containing $(g_\textsf{A}, y_\textsf{A})$ and protected by the script given below. She waits for Bob to join by spending $A$ subject to the conditions given in the script. Alice can spend $A$ if no one joins within 100 blocks. 
	\item \textbf{Mix:} Bob randomly picks one unspent box from the pool, for instance, $A$. Bob then picks a random secret bit $b$ and spends $A$ with another of his own unspent box $B$. The spending transaction creates two new unspent boxes $O_0, O_1$ of equal values such that $C_b$ is spendable only by Alice and $C_{1-b}$ is spendable only by Bob. This is done as follows:
	
	\begin{enumerate}
		%\item Bob selects a secret bit $b$. Then output $O_b$ is spendable by Bob alone, while $O_{1-b}$ is spendable by Alice alone. %Lets call these the intermediate boxes. 
		
		\item Bob picks secret $x_\textsf{B}\in \mathbb{Z}_q$. Let $g_\textsf{B} = {g_\textsf{A}}^{x_\textsf{B}}$ and $y_\textsf{B} = {y_\textsf{A}}^{x_\textsf{B}} = {g_\textsf{A}}^{x_\textsf{A}x_\textsf{B}}~(={g_\textsf{B}}^{x_\textsf{A}})$.  %Let $c_b = g^y$ and $c_{1-b} = g^{xy}$. Bob 
		The box $O_b$ contains the tuple $(g_\textsf{A}, y_\textsf{A}, g_\textsf{B}, y_\textsf{B})$ and $O_{1-b}$ contains $(g_\textsf{A}, y_\textsf{A}, y_\textsf{B}, g_\textsf{B})$. Assuming that the {\em Decision Diffie-Hellman Problem} in $G$ is hard, the distributions $(g_\textsf{A}, {g_\textsf{A}}^{x_\textsf{A}}, {g_\textsf{A}}^{x_\textsf{B}}, {g_\textsf{A}}^{x_\textsf{A}x_\textsf{B}})$ and $(g_\textsf{A}, {g_\textsf{A}}^{x_\textsf{A}}, {g_\textsf{A}}^{x_\textsf{A}x_\textsf{B}}, {g_\textsf{A}}^{x_\textsf{B}})$ are computationally indistinguishable. In other words, without knowledge of $x_\textsf{A}$ or $x_\textsf{B}$, one cannot guess $b$ with probability better than $1/2$.
		\item  Let 
		$s_\textsf{A}$ be the statement: ``For given $(g_\textsf{A}, y_\textsf{A}, g_\textsf{B}, y_\textsf{B})$ 
		prove knowledge of $x_\textsf{A}$ such that $y_\textsf{A} = {g_\textsf{A}}^{x_\textsf{A}}$ and ${y_\textsf{B}} = {g_\textsf{B}}^{x_\textsf{A}}$.'' This is encoded as $$s_\textsf{A} = (g_\textsf{A}, y_\textsf{A}, g_\textsf{B}, y_\textsf{B}) \mapsto \texttt{ProveDLogEq}(g_\textsf{A}, y_\textsf{A}, g_\textsf{B}, y_\textsf{B}).$$
		
		\item Let $s_{\textsf{B}}$ be the statement: ``For given $(g_\textsf{A}, y_\textsf{A}, y_\textsf{B}, g_\textsf{B})$
		prove knowledge of $x_\textsf{B}$ such that $g_\textsf{B} = {g_\textsf{A}}^{x_\textsf{B}}$ and $y_\textsf{B} = {y_\textsf{A}}^{x_\textsf{B}}$.''  This is encoded as $$s_\textsf{B} = (g_\textsf{A}, y_\textsf{A}, y_\textsf{B}, g_\textsf{B}) \mapsto \texttt{ProveDLogEq}(g_\textsf{A}, g_\textsf{B}, y_\textsf{A}, y_\textsf{B}).$$
		
		\snote{
			We can actually use a smaller statement for Bob:
			$$ s_\textsf{B} = (g_\textsf{A}, y_\textsf{A}, y_\textsf{B}, g_\textsf{B}) \mapsto \texttt{ProveDLog}(g_\textsf{A}, g_\textsf{B}). $$
		}
			Observe that the order of $g_\textsf{B}, y_\textsf{B}$ is reversed from $s_\textsf{A}$.
		\item Each box is protected by the statement $s_\textsf{A} \lor s_\textsf{B}$. 
		
	\end{enumerate}
	Alice's spending condition for $A$ is that the transaction should be as follows: 
	
	\begin{enumerate}
		\item It should contain two inputs, the first of which is $A$. The value of the second input should be the same as in $A$. 
		\item It should contain exactly two outputs $(O_0, O_1)$ of the form $(g_\textsf{A}, y_\textsf{A}, c_0, c_1)$ and $(g_\textsf{A}, y_\textsf{A}, c_1, c_0)$ respectively;
		\item It The spender must satisfy $\texttt{ProveDLogEq}(g_\textsf{A}, c_0, y_\textsf{A}, c_1)\lor \texttt{ProveDLogEq}(g_\textsf{A}, c_1, y_\textsf{A}, c_0)$.
		\item The outputs should be protected by the script 
		%Additionally, the spending condition for $O_0, O_1$ is $s_\textsf{Alice}(g_A, y_A, c_0, c_1) \lor s_\textsf{Bob}(g_A, y_A, c_0, c_1)$.
\end{enumerate}
	\item \textbf{Spend:} Both Alice and Bob later spent their respective boxes using their secrets. 
\end{enumerate}


\end{document}