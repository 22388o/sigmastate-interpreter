\section{Language}
\label{sec:language}

Here we define abstract syntax for \langname language. It is a typed
functional language with tuples, collections, optional types and \lst{val}
binding expressions. The semantics of \langname is specified by first
translating it to a core calculus (\corelang) and then by giving its
operational semantics. Typing rules are given in Section~\ref{sec:typing} and
big-step semantics are given in Section~\ref{sec:evaluation}.

\begin{figure}[h]
    \footnotesize
    \input{figures/fig_language.tex}
    \caption{Abstract syntax of ErgoScript language}
    \label{fig:language}
\end{figure}
    
We assign types to the terms in a standard way following typing rules shown
in Figure~\ref{fig:typing}.

Constants keep both the type and the data value of that type. To be
well-formed the type of the constant should correspond to its value.

Variables are always typed and identified by unique $id$, which refers to
either lambda bound variable of \lst{val} bound variable. The encoding of
variables and their resolution is described in Section~\ref{sec:blocks}.

Lambda expressions can take a list of lambda-bound variables which can be
used in the body expression, which can be \emph{block expression}. 

Function application takes an expression of functional type (e.g. $\tau_1 \to
\tau_n$) and a list of arguments. The reason we do not write it $e_f(\Ov{e})$
is that this notation suggests that $(\Ov{e})$ is a subterm, which it is not.

Method invocation allows to apply functions defined as methods of
\emph{interface types}. If expression $e$ has interface type $I$ and and
method $m$ is declared in the interface $I$ then method invocation
$e.m(args)$ is defined for the appropriate $args$.

Conditional expressions are strict in condition and lazy in both of the
branches. Each branch is an expression which is executed depending on the
result of condition. This laziness of branches specified by lowering to
\corelang (see Figure~\ref{fig:lowering}).

Block expression contains a list of \lst{val} definitions of variables. Each
subsequent definition can refer to the previously defined variables. Result
of block execution is the result of the resulting expression $e$, which can
use any variable of the block.

Each type may be associated with a list of method declarations, in which case
we say that \emph{the type has methods}. The semantics of the methods is the
same as in Java. Having an instance of some type with methods it is possible
to call methods on the instance with some additional arguments.

\begin{figure}[h]

\begin{center}
\begin{tabular}{ l c l }
$\Low{ \TyLam{x}{\tau}{e} 		}$ & \To & $\TyLam{x}{\tau}{ \Low{e} }$ \\	
$\Low{ \Apply{e_f}{\Ov{e_i}} 	}$ & \To & $\Apply{ \Low{e_f} }{ \Ov{\Low{e_i}} }$ \\	
$\Low{ \Apply{e.m}{\Ov{e}}		}$ & \To & $\Apply{ \Low{e}.m}{\Ov{ \Low{e} }}$ \\	
$\Low{ \Tup{e_1, \dots ,e_n}	}$ & \To & $\Tup{\Low{e_1}, \dots ,\Low{e_n}}$ \\	
$\Low{ \Apply{\delta}{\Ov{e}}	}$ & \To & $\Apply{\delta}{\Ov{ \Low{e} }}$ \\	

$\Low{ \IfThenElse{e_{cond}}{e_1}{e_2} }$ & \To & 
		$\Apply{(\IfThenElse{e_{cond}}{\Lam{(\_:Unit)}{\Low{e_1}}}{\Lam{(\_:Unit)}{\Low{e_2}}})}{}$ \\ 

$\Low{ \{ \Ov{\text{\lst{val}}~x_i: T_i = e_i;}~e\} }$ & \To &  
		$\Apply{ (\Lam{(x_1:T_1)}{( \dots \Apply{(\Lam{(x_n:T_n)}{\Low{e}})}{\Low{e_n}} \dots )}) }{\Low{e_1}}$\\

$\Low{ e }$ 	& \To &  $e$ \\	
\end{tabular}
\end{center}
    \caption{Lowering to \corelang}
    \label{fig:lowering}
\end{figure}