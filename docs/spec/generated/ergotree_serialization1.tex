
\subsubsection{\lst{ConcreteCollection} operation (OpCode 131)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ numItems $ & \lst{VLQ(UShort)} & [1, *] & number of item in a collection of expressions \\
    \hline
           $ elementType $ & \lst{Type} & [1, *] & type of each expression in the collection \\
    \hline
          \multicolumn{4}{l}{\lst{for}~$i=1$~\lst{to}~$numItems$} \\
    \hline
             ~~ $ item_i $ & \lst{Expr} & [1, *] & expression in i-th position \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{ConcreteCollectionBooleanConstant} operation (OpCode 133)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ numBits $ & \lst{VLQ(UShort)} & [1, *] & number of items in a collection of Boolean values \\
    \hline
           $ bits $ & \lst{Bits} & [1, 1024] & Boolean values encoded as as bits (right most byte is zero-padded on the right) \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Tuple} operation (OpCode 134)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ numItems $ & \lst{UByte} & 1 & number of items in the tuple \\
    \hline
          \multicolumn{4}{l}{\lst{for}~$i=1$~\lst{to}~$numItems$} \\
    \hline
             ~~ $ item_i $ & \lst{Expr} & [1, *] & tuple's item in i-th position \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{SelectField} operation (OpCode 140)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & tuple of items \\
    \hline
           $ fieldIndex $ & \lst{Byte} & 1 & index of an item to select \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{LT} operation (OpCode 143)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
          ~~~~ $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{LE} operation (OpCode 144)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
          ~~~~ $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{GT} operation (OpCode 145)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
          ~~~~ $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{GE} operation (OpCode 146)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
          ~~~~ $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{EQ} operation (OpCode 147)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{with}~$(Constant(l, Boolean), Constant(r, Boolean))$ } \\
    \hline
            ~~~~ $ opCode $ & \lst{Byte} & 1 & always contains OpCode 133 \\
    \hline
          ~~~~ $ (l,r) $ & \lst{Bits} & 1 & two higher bits in a byte \\
    \hline
      
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
          ~~~~ $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{NEQ} operation (OpCode 148)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{with}~$(Constant(l, Boolean), Constant(r, Boolean))$ } \\
    \hline
            ~~~~ $ opCode $ & \lst{Byte} & 1 & always contains OpCode 133 \\
    \hline
          ~~~~ $ (l,r) $ & \lst{Bits} & 1 & two higher bits in a byte \\
    \hline
      
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
          ~~~~ $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{If} operation (OpCode 149)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ condition $ & \lst{Expr} & [1, *] & condition expression \\
    \hline
           $ trueBranch $ & \lst{Expr} & [1, *] & expression to execute when \lst{condition == true} \\
    \hline
           $ falseBranch $ & \lst{Expr} & [1, *] & expression to execute when \lst{condition == false} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{AND} operation (OpCode 150)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ conditions $ & \lst{Expr} & [1, *] & a collection of conditions \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{OR} operation (OpCode 151)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ conditions $ & \lst{Expr} & [1, *] & a collection of conditions \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{AtLeast} operation (OpCode 152)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ bound $ & \lst{Expr} & [1, *] & required minimum of proven children \\
    \hline
           $ children $ & \lst{Expr} & [1, *] & proposition to be proven/validated \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Minus} operation (OpCode 153)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Plus} operation (OpCode 154)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Xor} operation (OpCode 155)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Multiply} operation (OpCode 156)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Division} operation (OpCode 157)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Modulo} operation (OpCode 158)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Exponentiate} operation (OpCode 159)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ k $ & \lst{Expr} & [1, *] & The power \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{MultiplyGroup} operation (OpCode 160)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ other $ & \lst{Expr} & [1, *] & other element of the group \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Min} operation (OpCode 161)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Max} operation (OpCode 162)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{MapCollection} operation (OpCode 173)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ f $ & \lst{Expr} & [1, *] & the function to apply to each element \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Exists} operation (OpCode 174)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ p $ & \lst{Expr} & [1, *] & the predicate used to test elements \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ForAll} operation (OpCode 175)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ p $ & \lst{Expr} & [1, *] & the predicate used to test elements \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Fold} operation (OpCode 176)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ zero $ & \lst{Expr} & [1, *] & a starting value \\
    \hline
           $ op $ & \lst{Expr} & [1, *] & the binary operator \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{SizeOf} operation (OpCode 177)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ByIndex} operation (OpCode 178)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ index $ & \lst{Expr} & [1, *] & index of the element of this collection \\
    \hline
          \multicolumn{4}{l}{\lst{optional}~$default$} \\
    \hline
    ~~$tag$ & \lst{Byte} & 1 & 0 - no value; 1 - has value \\
    \hline
    \multicolumn{4}{l}{~~\lst{when}~$tag == 1$} \\
    \hline
             ~~~~ $ default $ & \lst{Expr} & [1, *] & value to return when \lst{index} is out of range \\
    \hline
          \multicolumn{4}{l}{\lst{end optional}} \\
\end{tabularx}\)
       

\subsubsection{\lst{Append} operation (OpCode 179)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ other $ & \lst{Expr} & [1, *] & the collection to append at the end of this \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Slice} operation (OpCode 180)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ from $ & \lst{Expr} & [1, *] & the lowest index to include from this collection \\
    \hline
           $ until $ & \lst{Expr} & [1, *] & the lowest index to EXCLUDE from this collection \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{TreeLookup} operation (OpCode 183)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ tree $ & \lst{Expr} & [1, *] & tree to lookup the key \\
    \hline
           $ key $ & \lst{Expr} & [1, *] & a key of an item in the \lst{tree} to lookup \\
    \hline
           $ proof $ & \lst{Expr} & [1, *] & proof to perform verification of the operation \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractAmount} operation (OpCode 193)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractScriptBytes} operation (OpCode 194)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractBytes} operation (OpCode 195)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractBytesWithNoRef} operation (OpCode 196)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractId} operation (OpCode 197)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractRegisterAs} operation (OpCode 198)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ regId $ & \lst{Byte} & 1 & zero-based identifier of the register. \\
    \hline
           $ type $ & \lst{Type} & [1, *] & expected type of the value in register \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractCreationInfo} operation (OpCode 199)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{CalcBlake2b256} operation (OpCode 203)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & collection of bytes \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{CalcSha256} operation (OpCode 204)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & collection of bytes \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{CreateProveDlog} operation (OpCode 205)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ value $ & \lst{Expr} & [1, *] & element of elliptic curve group \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{CreateProveDHTuple} operation (OpCode 206)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ g $ & \lst{Expr} & [1, *] &  \\
    \hline
           $ h $ & \lst{Expr} & [1, *] &  \\
    \hline
           $ u $ & \lst{Expr} & [1, *] &  \\
    \hline
           $ v $ & \lst{Expr} & [1, *] &  \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{SigmaPropBytes} operation (OpCode 208)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{BoolToSigmaProp} operation (OpCode 209)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ condition $ & \lst{Expr} & [1, *] & boolean value to embed in SigmaProp value \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{DeserializeContext} operation (OpCode 212)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ type $ & \lst{Type} & [1, *] & expected type of the deserialized script \\
    \hline
           $ id $ & \lst{Byte} & 1 & identifier of the context variable \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{DeserializeRegister} operation (OpCode 213)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ id $ & \lst{Byte} & 1 & identifier of the register \\
    \hline
           $ type $ & \lst{Type} & [1, *] & expected type of the deserialized script \\
    \hline
          \multicolumn{4}{l}{\lst{optional}~$default$} \\
    \hline
    ~~$tag$ & \lst{Byte} & 1 & 0 - no value; 1 - has value \\
    \hline
    \multicolumn{4}{l}{~~\lst{when}~$tag == 1$} \\
    \hline
             ~~~~ $ default $ & \lst{Expr} & [1, *] & optional default value, if register is not available \\
    \hline
          \multicolumn{4}{l}{\lst{end optional}} \\
\end{tabularx}\)
       

\subsubsection{\lst{ValDef} operation (OpCode 214)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    % skipped OptionalScope(type arguments, ArrayBuffer())

\end{tabularx}\)
       

\subsubsection{\lst{FunDef} operation (OpCode 215)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    % skipped OptionalScope(type arguments, ArrayBuffer())

\end{tabularx}\)
       

\subsubsection{\lst{BlockValue} operation (OpCode 216)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ numItems $ & \lst{VLQ(UInt)} & [1, *] & number of block items \\
    \hline
          \multicolumn{4}{l}{\lst{for}~$i=1$~\lst{to}~$numItems$} \\
    \hline
             ~~ $ item_i $ & \lst{Expr} & [1, *] & block's item in i-th position \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\\hline
     $ result $ & \lst{Expr} & [1, *] & result expression of the block \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{FuncValue} operation (OpCode 217)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ numArgs $ & \lst{VLQ(UInt)} & [1, *] & number of function arguments \\
    \hline
          \multicolumn{4}{l}{\lst{for}~$i=1$~\lst{to}~$numArgs$} \\
    \hline
             ~~ $ id_i $ & \lst{VLQ(UInt)} & [1, *] & identifier of the i-th argument \\
    \hline
          ~~ $ type_i $ & \lst{Type} & [1, *] & type of the i-th argument \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\\hline
     $ body $ & \lst{Expr} & [1, *] & function body, which is parameterized by arguments \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Apply} operation (OpCode 218)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ func $ & \lst{Expr} & [1, *] & function which is applied \\
    \hline
           $ \#items $ & \lst{VLQ(UInt)} & [1, *] & number of items in the collection \\
    \hline
          \multicolumn{4}{l}{\lst{for}~$i=1$~\lst{to}~$\#items$} \\
    \hline
             ~~ $ args_i $ & \lst{Expr} & [1, *] & i-th item in the list of arguments \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{PropertyCall} operation (OpCode 219)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ typeCode $ & \lst{Byte} & 1 & type of the method (see Table~\ref{table:predeftypes}) \\
    \hline
           $ methodCode $ & \lst{Byte} & 1 & a code of the proprty \\
    \hline
           $ obj $ & \lst{Expr} & [1, *] & receiver object of this property call \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{MethodCall} operation (OpCode 220)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ typeCode $ & \lst{Byte} & 1 & type of the method (see Table~\ref{table:predeftypes}) \\
    \hline
           $ methodCode $ & \lst{Byte} & 1 & a code of the method \\
    \hline
           $ obj $ & \lst{Expr} & [1, *] & receiver object of this method call \\
    \hline
           $ \#items $ & \lst{VLQ(UInt)} & [1, *] & number of items in the collection \\
    \hline
          \multicolumn{4}{l}{\lst{for}~$i=1$~\lst{to}~$\#items$} \\
    \hline
             ~~ $ args_i $ & \lst{Expr} & [1, *] & i-th item in the arguments of the method call \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{GetVar} operation (OpCode 227)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ varId $ & \lst{Byte} & 1 & \lst{Byte} identifier of context variable \\
    \hline
           $ type $ & \lst{Type} & [1, *] & expected type of context variable \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{OptionGet} operation (OpCode 228)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{OptionGetOrElse} operation (OpCode 229)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ default $ & \lst{Expr} & [1, *] & the default value \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{OptionIsDefined} operation (OpCode 230)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ModQ} operation (OpCode 231)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{PlusModQ} operation (OpCode 232)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ other $ & \lst{Expr} & [1, *] & Number to add to this. \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{MinusModQ} operation (OpCode 233)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ this $ & \lst{Expr} & [1, *] & this instance \\
    \hline
           $ other $ & \lst{Expr} & [1, *] & Number to add to this. \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{SigmaAnd} operation (OpCode 234)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ \#items $ & \lst{VLQ(UInt)} & [1, *] & number of items in the collection \\
    \hline
          \multicolumn{4}{l}{\lst{for}~$i=1$~\lst{to}~$\#items$} \\
    \hline
             ~~ $ propositions_i $ & \lst{Expr} & [1, *] & i-th item in the a collection of propositions \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{SigmaOr} operation (OpCode 235)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ \#items $ & \lst{VLQ(UInt)} & [1, *] & number of items in the collection \\
    \hline
          \multicolumn{4}{l}{\lst{for}~$i=1$~\lst{to}~$\#items$} \\
    \hline
             ~~ $ propositions_i $ & \lst{Expr} & [1, *] & i-th item in the a collection of propositions \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{BinOr} operation (OpCode 236)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
          ~~~~ $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{BinAnd} operation (OpCode 237)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
          ~~~~ $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{DecodePoint} operation (OpCode 238)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & serialized bytes of some \lst{GroupElement} value \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{LogicalNot} operation (OpCode 239)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & input \lst{Boolean} value \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Negation} operation (OpCode 240)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & value of numeric type \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{BitInversion} operation (OpCode 241)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & value of numeric type \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{BitOr} operation (OpCode 242)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{BitAnd} operation (OpCode 243)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{BinXor} operation (OpCode 244)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{with}~$(Constant(l, Boolean), Constant(r, Boolean))$ } \\
    \hline
            ~~~~ $ opCode $ & \lst{Byte} & 1 & always contains OpCode 133 \\
    \hline
          ~~~~ $ (l,r) $ & \lst{Bits} & 1 & two higher bits in a byte \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{BitXor} operation (OpCode 245)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{BitShiftRight} operation (OpCode 246)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{BitShiftLeft} operation (OpCode 247)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{BitShiftRightZeroed} operation (OpCode 248)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ left $ & \lst{Expr} & [1, *] & left operand \\
    \hline
           $ right $ & \lst{Expr} & [1, *] & right operand \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{XorOf} operation (OpCode 255)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ conditions $ & \lst{Expr} & [1, *] & a collection of conditions \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{SubstConstants} operation (OpCode 116)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ scriptBytes $ & \lst{Expr} & [1, *] & serialized ErgoTree with ConstantSegregationFlag set to 1. \\
    \hline
           $ positions $ & \lst{Expr} & [1, *] & zero based indexes in ErgoTree.constants array which should be replaced with new values \\
    \hline
           $ newValues $ & \lst{Expr} & [1, *] & new values to be injected into the corresponding positions in ErgoTree.constants array \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{LongToByteArray} operation (OpCode 122)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & value to convert \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ByteArrayToBigInt} operation (OpCode 123)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & collection of bytes in big-endian format \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ByteArrayToLong} operation (OpCode 124)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & collection of bytes in big-endian format \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Downcast} operation (OpCode 125)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & value to cast \\
    \hline
           $ type $ & \lst{Type} & [1, *] & resulting type of the cast operation \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Upcast} operation (OpCode 126)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         $ input $ & \lst{Expr} & [1, *] & value to cast \\
    \hline
           $ type $ & \lst{Type} & [1, *] & resulting type of the cast operation \\
    \hline
      
\end{tabularx}\)
       