
\subsubsection{\lst{ConcreteCollection} operation (OpCode 131)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         numItems & \lst{VLQ(UShort)} & \text{[1, *]} & \text{number of item in a collection of expressions} \\
    \hline
           elementType & \lst{Type} & \text{[1, *]} & \text{type of each expression in the collection} \\
    \hline
          \multicolumn{4}{l}{\lst{for}~i=1~\lst{to}~numItems} \\
    \hline
             ~~ item_i & \lst{Expr} & \text{[1, *]} & \text{expression in i-th position} \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{ConcreteCollectionBooleanConstant} operation (OpCode 133)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         numBits & \lst{VLQ(UShort)} & \text{[1, *]} & \text{number of items in a collection of Boolean values} \\
    \hline
           bits & \lst{Bits} & \text{[1, 1024]} & \text{Boolean values encoded as as bits (right most byte is zero-padded on the right)} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Tuple} operation (OpCode 134)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         numItems & \lst{UByte} & \text{1} & \text{number of items in the tuple} \\
    \hline
          \multicolumn{4}{l}{\lst{for}~i=1~\lst{to}~numItems} \\
    \hline
             ~~ item_i & \lst{Expr} & \text{[1, *]} & \text{tuple's item in i-th position} \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{SelectField} operation (OpCode 140)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         input & \lst{Expr} & \text{[1, *]} & \text{tuple of items} \\
    \hline
           fieldIndex & \lst{Byte} & \text{1} & \text{index of an item to select} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{LT} operation (OpCode 143)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
          ~~~~ right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{LE} operation (OpCode 144)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
          ~~~~ right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{GT} operation (OpCode 145)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
          ~~~~ right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{GE} operation (OpCode 146)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
          ~~~~ right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{EQ} operation (OpCode 147)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{with}~(Constant(l, Boolean), Constant(r, Boolean)) } \\
    \hline
            ~~~~ opCode & \lst{Byte} & \text{1} & \text{always contains OpCode 133} \\
    \hline
          ~~~~ (l,r) & \lst{Bits} & \text{1} & \text{two higher bits in a byte} \\
    \hline
      
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
          ~~~~ right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{NEQ} operation (OpCode 148)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
        \multicolumn{4}{l}{\lst{match}~$ (left, right) $} \\
         
    \multicolumn{4}{l}{~~\lst{with}~(Constant(l, Boolean), Constant(r, Boolean)) } \\
    \hline
            ~~~~ opCode & \lst{Byte} & \text{1} & \text{always contains OpCode 133} \\
    \hline
          ~~~~ (l,r) & \lst{Bits} & \text{1} & \text{two higher bits in a byte} \\
    \hline
      
    \multicolumn{4}{l}{~~\lst{otherwise} } \\
    \hline
            ~~~~ left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
          ~~~~ right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
          \multicolumn{4}{l}{\lst{end match}} \\
\end{tabularx}\)
       

\subsubsection{\lst{If} operation (OpCode 149)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         condition & \lst{Expr} & \text{[1, *]} & \text{condition expression} \\
    \hline
           trueBranch & \lst{Expr} & \text{[1, *]} & \text{expression to execute when \lst{condition == true}} \\
    \hline
           falseBranch & \lst{Expr} & \text{[1, *]} & \text{expression to execute when \lst{condition == false}} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{AND} operation (OpCode 150)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         conditions & \lst{Expr} & \text{[1, *]} & \text{a collection of conditions} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{AtLeast} operation (OpCode 152)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         bound & \lst{Expr} & \text{[1, *]} & \text{required minimum of proven children} \\
    \hline
           children & \lst{Expr} & \text{[1, *]} & \text{proposition to be proven/validated} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Minus} operation (OpCode 153)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
           right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Plus} operation (OpCode 154)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
           right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Xor} operation (OpCode 155)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
           right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Multiply} operation (OpCode 156)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
           right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Division} operation (OpCode 157)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
           right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Modulo} operation (OpCode 158)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
           right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Exponentiate} operation (OpCode 159)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           k & \lst{Expr} & \text{[1, *]} & \text{The power} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{MultiplyGroup} operation (OpCode 160)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           other & \lst{Expr} & \text{[1, *]} & \text{other element of the group} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Min} operation (OpCode 161)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
           right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Max} operation (OpCode 162)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         left & \lst{Expr} & \text{[1, *]} & \text{left operand} \\
    \hline
           right & \lst{Expr} & \text{[1, *]} & \text{right operand} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{MapCollection} operation (OpCode 173)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           f & \lst{Expr} & \text{[1, *]} & \text{the function to apply to each element} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Exists} operation (OpCode 174)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           p & \lst{Expr} & \text{[1, *]} & \text{the predicate used to test elements} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ForAll} operation (OpCode 175)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           p & \lst{Expr} & \text{[1, *]} & \text{the predicate used to test elements} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Fold} operation (OpCode 176)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           zero & \lst{Expr} & \text{[1, *]} & \text{a starting value} \\
    \hline
           op & \lst{Expr} & \text{[1, *]} & \text{the binary operator} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{SizeOf} operation (OpCode 177)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ByIndex} operation (OpCode 178)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           index & \lst{Expr} & \text{[1, *]} & \text{index of the element of this collection} \\
    \hline
          \multicolumn{4}{l}{\lst{optional}~default} \\
    \hline
    ~~tag & \lst{Byte} & 1 & \text{0 - no value; 1 - has value} \\
    \hline
    \multicolumn{4}{l}{~~\lst{when}~tag == 1} \\
    \hline
             ~~~~ default & \lst{Expr} & \text{[1, *]} & \text{value to return when \lst{index} is out of range} \\
    \hline
          \multicolumn{4}{l}{\lst{end optional}} \\
\end{tabularx}\)
       

\subsubsection{\lst{Append} operation (OpCode 179)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           other & \lst{Expr} & \text{[1, *]} & \text{the collection to append at the end of this} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Slice} operation (OpCode 180)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           from & \lst{Expr} & \text{[1, *]} & \text{the lowest index to include from this collection} \\
    \hline
           until & \lst{Expr} & \text{[1, *]} & \text{the lowest index to EXCLUDE from this collection} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{TreeLookup} operation (OpCode 183)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         tree & \lst{Expr} & \text{[1, *]} & \text{tree to lookup the key} \\
    \hline
           key & \lst{Expr} & \text{[1, *]} & \text{a key of an item in the \lst{tree} to lookup} \\
    \hline
           proof & \lst{Expr} & \text{[1, *]} & \text{proof to perform verification of the operation} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractAmount} operation (OpCode 193)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractScriptBytes} operation (OpCode 194)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractBytes} operation (OpCode 195)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractBytesWithNoRef} operation (OpCode 196)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractId} operation (OpCode 197)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractRegisterAs} operation (OpCode 198)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           regId & \lst{Byte} & \text{1} & \text{zero-based identifier of the register.} \\
    \hline
           type & \lst{Type} & \text{[1, *]} & \text{expected type of the value in register} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ExtractCreationInfo} operation (OpCode 199)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{CalcBlake2b256} operation (OpCode 203)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         input & \lst{Expr} & \text{[1, *]} & \text{collection of bytes} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{CalcSha256} operation (OpCode 204)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         input & \lst{Expr} & \text{[1, *]} & \text{collection of bytes} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{BoolToSigmaProp} operation (OpCode 209)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         condition & \lst{Expr} & \text{[1, *]} & \text{boolean value to embed in SigmaProp value} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{DeserializeContext} operation (OpCode 212)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         type & \lst{Type} & \text{[1, *]} & \text{expected type of the deserialized script} \\
    \hline
           id & \lst{Byte} & \text{1} & \text{identifier of the context variable} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{DeserializeRegister} operation (OpCode 213)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         id & \lst{Byte} & \text{1} & \text{identifier of the register} \\
    \hline
           type & \lst{Type} & \text{[1, *]} & \text{expected type of the deserialized script} \\
    \hline
          \multicolumn{4}{l}{\lst{optional}~default} \\
    \hline
    ~~tag & \lst{Byte} & 1 & \text{0 - no value; 1 - has value} \\
    \hline
    \multicolumn{4}{l}{~~\lst{when}~tag == 1} \\
    \hline
             ~~~~ default & \lst{Expr} & \text{[1, *]} & \text{optional default value, if register is not available} \\
    \hline
          \multicolumn{4}{l}{\lst{end optional}} \\
\end{tabularx}\)
       

\subsubsection{\lst{ValDef} operation (OpCode 214)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    % skipped OptionalScope(type arguments, ArrayBuffer())

\end{tabularx}\)
       

\subsubsection{\lst{FunDef} operation (OpCode 215)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    % skipped OptionalScope(type arguments, ArrayBuffer())

\end{tabularx}\)
       

\subsubsection{\lst{BlockValue} operation (OpCode 216)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         numItems & \lst{VLQ(UInt)} & \text{[1, *]} & \text{number of block items} \\
    \hline
          \multicolumn{4}{l}{\lst{for}~i=1~\lst{to}~numItems} \\
    \hline
             ~~ item_i & \lst{Expr} & \text{[1, *]} & \text{block's item in i-th position} \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\\hline
     result & \lst{Expr} & \text{[1, *]} & \text{result expression of the block} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{FuncValue} operation (OpCode 217)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         numArgs & \lst{VLQ(UInt)} & \text{[1, *]} & \text{number of function arguments} \\
    \hline
          \multicolumn{4}{l}{\lst{for}~i=1~\lst{to}~numArgs} \\
    \hline
             ~~ id_i & \lst{VLQ(UInt)} & \text{[1, *]} & \text{identifier of the i-th argument} \\
    \hline
          ~~ type_i & \lst{Type} & \text{[1, *]} & \text{type of the i-th argument} \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\\hline
     body & \lst{Expr} & \text{[1, *]} & \text{function body, which is parameterized by arguments} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{PropertyCall} operation (OpCode 219)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         typeCode & \lst{Byte} & \text{1} & \text{type of the method (see Table~\ref{table:predeftypes})} \\
    \hline
           methodCode & \lst{Byte} & \text{1} & \text{a code of the proprty} \\
    \hline
           obj & \lst{Expr} & \text{[1, *]} & \text{receiver object of this property call} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{MethodCall} operation (OpCode 220)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         typeCode & \lst{Byte} & \text{1} & \text{type of the method (see Table~\ref{table:predeftypes})} \\
    \hline
           methodCode & \lst{Byte} & \text{1} & \text{a code of the method} \\
    \hline
           obj & \lst{Expr} & \text{[1, *]} & \text{receiver object of this method call} \\
    \hline
           \#items & \lst{VLQ(UInt)} & \text{[1, *]} & \text{number of items in the collection} \\
    \hline
          \multicolumn{4}{l}{\lst{for}~i=1~\lst{to}~\#items} \\
    \hline
             ~~ args_i & \lst{Expr} & \text{[1, *]} & \text{i-th item in the arguments of the method call} \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{GetVar} operation (OpCode 227)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         varId & \lst{Byte} & \text{1} & \text{\lst{Byte} identifier of context variable} \\
    \hline
           type & \lst{Type} & \text{[1, *]} & \text{expected type of context variable} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{OptionGet} operation (OpCode 228)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{OptionGetOrElse} operation (OpCode 229)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           default & \lst{Expr} & \text{[1, *]} & \text{the default value} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{OptionIsDefined} operation (OpCode 230)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ModQ} operation (OpCode 231)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{PlusModQ} operation (OpCode 232)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           other & \lst{Expr} & \text{[1, *]} & \text{Number to add to this.} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{MinusModQ} operation (OpCode 233)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         this & \lst{Expr} & \text{[1, *]} & \text{this instance} \\
    \hline
           other & \lst{Expr} & \text{[1, *]} & \text{Number to add to this.} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{SigmaAnd} operation (OpCode 234)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         \#items & \lst{VLQ(UInt)} & \text{[1, *]} & \text{number of items in the collection} \\
    \hline
          \multicolumn{4}{l}{\lst{for}~i=1~\lst{to}~\#items} \\
    \hline
             ~~ propositions_i & \lst{Expr} & \text{[1, *]} & \text{i-th item in the a collection of propositions} \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{SigmaOr} operation (OpCode 235)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         \#items & \lst{VLQ(UInt)} & \text{[1, *]} & \text{number of items in the collection} \\
    \hline
          \multicolumn{4}{l}{\lst{for}~i=1~\lst{to}~\#items} \\
    \hline
             ~~ propositions_i & \lst{Expr} & \text{[1, *]} & \text{i-th item in the a collection of propositions} \\
    \hline
          \multicolumn{4}{l}{\lst{end for}} \\
\end{tabularx}\)
       

\subsubsection{\lst{XorOf} operation (OpCode 255)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         conditions & \lst{Expr} & \text{[1, *]} & \text{a collection of conditions} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{SubstConstants} operation (OpCode 116)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         scriptBytes & \lst{Expr} & \text{[1, *]} & \text{serialized ErgoTree with ConstantSegregationFlag set to 1.} \\
    \hline
           positions & \lst{Expr} & \text{[1, *]} & \text{zero based indexes in ErgoTree.constants array which should be replaced with new values} \\
    \hline
           newValues & \lst{Expr} & \text{[1, *]} & \text{new values to be injected into the corresponding positions in ErgoTree.constants array} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{LongToByteArray} operation (OpCode 122)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         input & \lst{Expr} & \text{[1, *]} & \text{value to convert} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ByteArrayToBigInt} operation (OpCode 123)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         input & \lst{Expr} & \text{[1, *]} & \text{collection of bytes in big-endian format} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{ByteArrayToLong} operation (OpCode 124)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         input & \lst{Expr} & \text{[1, *]} & \text{collection of bytes in big-endian format} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Downcast} operation (OpCode 125)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         input & \lst{Expr} & \text{[1, *]} & \text{value to cast} \\
    \hline
           type & \lst{Type} & \text{[1, *]} & \text{resulting type of the cast operation} \\
    \hline
      
\end{tabularx}\)
       

\subsubsection{\lst{Upcast} operation (OpCode 126)}

\noindent
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
         input & \lst{Expr} & \text{[1, *]} & \text{value to cast} \\
    \hline
           type & \lst{Type} & \text{[1, *]} & \text{resulting type of the cast operation} \\
    \hline
      
\end{tabularx}\)
       