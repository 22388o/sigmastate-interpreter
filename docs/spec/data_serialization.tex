\subsection{Data Serialization}
\label{sec:ser:data}

In \langname all runtime data values have an associated type also available
at runtime (this is called \emph{type reification}\cite{Reification}).
However serialization format separates data values from its type descriptors. 
This allows to save space when for example a collection of items is serialized.

The contents of a typed data structure can be fully described by a type tree.
For example having a typed data object \lst{d: (Int, Coll[Byte], Boolean)} we can
tell that \lst{d} has 3 items, the first item contain 32-bit integer, the second
- collection of bytes, and the third - logical true/false value.

To serialize/deserialize typed data we need to know its type descriptor (type
tree). Serialization procedure is recursive over type tree and the
corresponding subcomponents of an object. For primitive types (the leaves of
the type tree) the format is fixed. The data values of \langname types are
serialized using predefined function shown in Figure~\ref{fig:ser:data}.

\begin{figure}[h]
\footnotesize
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    \hline
    \multicolumn{4}{l}{\lst{def serializeData(}$t, v$\lst{)}} \\
    \multicolumn{4}{l}{~~\lst{match} $(t, v)$ } \\

    \multicolumn{4}{l}{~~~~\lst{with} $(Unit, v \in \Denot{Unit})$~~~// nothing serialized } \\
    \multicolumn{4}{l}{~~~~\lst{with} $(Boolean, v \in \Denot{Boolean})$} \\
    \hline
    $~~~~~~v$ & \lst{Byte} & 1 & 0 or 1 in a single byte \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(Byte, v \in \Denot{Byte})$} \\
    \hline
    $~~~~~~v$  & \lst{Byte} & 1 &  in a single byte \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(N, v \in \Denot{Short}), N \in {Short, Int, Long}$} \\
    \hline
    $~~~~~~v$  & \lst{VLQ(ZigZag($$N$$))} & [1..3] & 
      16,32,64-bit signed integer encoded using \hyperref[sec:zigzag-encoding]{ZigZag} 
      and then using \hyperref[sec:vlq-encoding]{VLQ} \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(BigInt, v \in \Denot{BigInt})$} \\
    \multicolumn{4}{l}{~~~~~~$bytes = v$\lst{.toByteArray} } \\
    \hline
    $~~~~~~numBytes$  & \lst{VLQ(UInt)} &  & number of bytes in $bytes$ array \\
    \hline
    $~~~~~~bytes$  & \lst{Bytes} &  & serialized $bytes$ array \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(GroupElement, v \in \Denot{GroupElement})$} \\
    \hline
    ~~~~~~$v$  & \lst{GroupElement} &  & serialization of GroupElement data. See~\ref{sec:ser:data:groupelement} \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(SigmaProp, v \in \Denot{SigmaProp})$} \\
    \hline
    ~~~~~~$v$  & \lst{SigmaProp} &  & serialization of SigmaProp data. See~\ref{sec:ser:data:sigmaprop} \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(Box, v \in \Denot{Box})$} \\
    \hline
    ~~~~~~$v$  & \lst{Box} &  & serialization of Box data. See~\ref{sec:ser:data:box} \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(AvlTree, v \in \Denot{AvlTree})$} \\
    \hline
    ~~~~~~$v$  & \lst{AvlTree} &  & serialization of AvlTree data. See~\ref{sec:ser:data:avltree} \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(Coll[T], v \in \Denot{Coll[T]})$} \\
    \hline
    $~~~~~~len$  & \lst{VLQ(UShort)} & [1..3] & length of the collection \\
    \hline
    \multicolumn{4}{l}{~~~~~~\lst{match} $(T, v)$ } \\

    \multicolumn{4}{l}{~~~~~~~~\lst{with} $(Boolean, v \in \Denot{Coll[Boolean]})$} \\
    \hline
    $~~~~~~~~~~items$  & \lst{Bits} & [1..1024] & boolean values packed in bits \\
    \hline

    \multicolumn{4}{l}{~~~~~~~~\lst{with} $(Byte, v \in \Denot{Coll[Byte]})$} \\
    \hline
    $~~~~~~~~~~items$  & \lst{Bytes} & $[1..len]$ & items of the collection  \\
    \hline
    \multicolumn{4}{l}{~~~~~~~~\lst{otherwise} } \\
    \multicolumn{4}{l}{~~~~~~~~~~\lst{for}~$i=1$~\lst{to}~$len$} \\
    \multicolumn{4}{l}{~~~~~~~~~~~~\lst{serializeData(}$T, v_i$\lst{)}} \\
    \multicolumn{4}{l}{~~~~~~~~~~\lst{end for}} \\
    \multicolumn{4}{l}{~~~~~~\lst{end match}} \\

    \multicolumn{4}{l}{~~\lst{end match}} \\
    \multicolumn{4}{l}{\lst{end serializeData}} \\
    \hline
    \hline
\end{tabularx}\)
\caption{Data serialization format}
\label{fig:ser:data}
\end{figure}

\subsubsection{GroupElement serialization}
\label{sec:ser:data:groupelement}

\begin{figure}[h]
\footnotesize
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    \multicolumn{4}{l}{\lst{def serialize(}$ge$\lst{)}} \\
    \multicolumn{4}{l}{~~\lst{if} $ge.isIdentity$ \lst{then}} \\
    \hline
    ~~~~$ $  & \lst{Const} & $ $ &  \\ 
    \hline
    \multicolumn{4}{l}{~~\lst{else}} \\
    \hline
    ~~~~$ $  &  & $ $ &  \\ 
    \hline
    \multicolumn{4}{l}{~~\lst{end if}} \\
    \multicolumn{4}{l}{\lst{end def}} \\
\end{tabularx}\)
\caption{GroupElement serialization format}
\label{fig:ser:data:groupelement}
\end{figure}

\subsubsection{SigmaProp serialization}
\label{sec:ser:data:sigmaprop}
\begin{figure}[h]
\footnotesize
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
\end{tabularx}\)
\caption{SigmaProp serialization format}
\label{fig:ser:data:sigmaprop}
\end{figure}

\subsubsection{Box serialization}
\label{sec:ser:data:box}
\begin{figure}[h]
\footnotesize
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
\end{tabularx}\)
\caption{Box serialization format}
\label{fig:ser:data:box}
\end{figure}

\subsubsection{AvlTree serialization}
\label{sec:ser:data:avltree}
\begin{figure}[h]
\footnotesize
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
\end{tabularx}\)
\caption{AvlTree serialization format}
\label{fig:ser:data:avltree}
\end{figure}
