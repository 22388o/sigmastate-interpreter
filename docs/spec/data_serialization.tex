\subsection{Data Serialization}
\label{sec:ser:data}

In \langname all runtime data values have an associated type also available
at runtime (this is called \emph{type reification}\cite{Reification}).
However serialization format separates data values from its type descriptors. 
This allows to save space when for example a collection of items is serialized.

It is done is such a way that the contents of a typed data structure can be fully
described by a type tree. For example having a typed data object \lst{d: (Int,
Coll[Byte], Boolean)} we can tell that \lst{d} has 3 items, the first item contain
32-bit integer, the second - collection of bytes, and the third - logical true/false
value.

To serialize/deserialize typed data we need to know its \emph{type descriptor} (type
tree). The data serialization procedure is recursive over a type tree and the corresponding
sub-components of the data object. For primitive types (the leaves of the type tree) the
format is fixed. The data values of \langname types are serialized using the predefined
recursive function shown in Figure~\ref{fig:ser:data}.

\begin{figure}[H] \footnotesize
\caption{Data serialization format}\vspace{-7pt}
\label{fig:ser:data}
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    \hline
    \multicolumn{4}{l}{\lst{def serializeData(}$t, v$\lst{)}} \\
    \multicolumn{4}{l}{~~\lst{match} $(t, v)$ } \\

    \multicolumn{4}{l}{~~~~\lst{with} $(Unit, v \in \Denot{Unit})$~~~// nothing serialized } \\
    \multicolumn{4}{l}{~~~~\lst{with} $(Boolean, v \in \Denot{Boolean})$} \\
    \hline
    $~~~~~~v$ & \lst{Byte} & 1 & 0 if $v = false$ or 1 otherwise \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(Byte, v \in \Denot{Byte})$} \\
    \hline
    $~~~~~~v$  & \lst{Byte} & 1 &  in a single byte \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(N, v \in \Denot{N}), N \in {Short, Int, Long}$} \\
    \hline
    $~~~~~~v$  & \lst{VLQ(ZigZag($$N$$))} & [1..3] & 
      16,32,64-bit signed integer encoded using \hyperref[sec:zigzag-encoding]{ZigZag} 
      and then \hyperref[sec:vlq-encoding]{VLQ} \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(BigInt, v \in \Denot{BigInt})$} \\
    \multicolumn{4}{l}{~~~~~~$bytes = v$\lst{.toByteArray} } \\
    \hline
    $~~~~~~numBytes$  & \lst{VLQ(UInt)} &  & number of bytes in $bytes$ array \\
    \hline
    $~~~~~~bytes$  & \lst{Bytes} &  & serialized $bytes$ array \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(GroupElement, v \in \Denot{GroupElement})$} \\
    \hline
    ~~~~~~$v$  & \lst{GroupElement} &  & serialization of GroupElement data. See~\ref{sec:ser:data:groupelement} \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(SigmaProp, v \in \Denot{SigmaProp})$} \\
    \hline
    ~~~~~~$v$  & \lst{SigmaProp} &  & serialization of SigmaProp data. See~\ref{sec:ser:data:sigmaprop} \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(Box, v \in \Denot{Box})$} \\
    \hline
    ~~~~~~$v$  & \lst{Box} &  & serialization of Box data. See~\ref{sec:ser:data:box} \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(AvlTree, v \in \Denot{AvlTree})$} \\
    \hline
    ~~~~~~$v$  & \lst{AvlTree} &  & serialization of AvlTree data. See~\ref{sec:ser:data:avltree} \\

    \hline
    \multicolumn{4}{l}{~~~~\lst{with} $(Coll[T], v \in \Denot{Coll[T]})$} \\
    \hline
    $~~~~~~len$  & \lst{VLQ(UShort)} & [1..3] & length of the collection \\
    \hline
    \multicolumn{4}{l}{~~~~~~\lst{match} $(T, v)$ } \\

    \multicolumn{4}{l}{~~~~~~~~\lst{with} $(Boolean, v \in \Denot{Coll[Boolean]})$} \\
    \hline
    $~~~~~~~~~~items$  & \lst{Bits} & [1..1024] & boolean values packed in bits \\
    \hline

    \multicolumn{4}{l}{~~~~~~~~\lst{with} $(Byte, v \in \Denot{Coll[Byte]})$} \\
    \hline
    $~~~~~~~~~~items$  & \lst{Bytes} & $[1..len]$ & items of the collection  \\
    \hline
    \multicolumn{4}{l}{~~~~~~~~\lst{otherwise} } \\
    \multicolumn{4}{l}{~~~~~~~~~~\lst{for}~$i=1$~\lst{to}~$len$~\lst{do}~\lst{serializeData(}$T, v_i$\lst{) end for}} \\
    \multicolumn{4}{l}{~~~~~~\lst{end match}} \\
    \multicolumn{4}{l}{~~\lst{end match}} \\
    \multicolumn{4}{l}{\lst{end serializeData}} \\
    \hline
    \hline
\end{tabularx}\)
\end{figure}

\subsubsection{GroupElement serialization}
\label{sec:ser:data:groupelement}

\begin{figure}[H] \footnotesize
\caption{GroupElement serialization format}\vspace{-7pt}
\label{fig:ser:data:groupelement}
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    \multicolumn{4}{l}{\lst{def serialize(}$ge$\lst{)}} \\
    \multicolumn{4}{l}{~~\lst{if} $ge.isIdentity$ \lst{then}} \\
    \hline
    ~~~~$ $  & \lst{Const} & $ $ &  \\ 
    \hline
    \multicolumn{4}{l}{~~\lst{else}} \\
    \hline
    ~~~~$ $  &  & $ $ &  \\ 
    \hline
    \multicolumn{4}{l}{~~\lst{end if}} \\
    \multicolumn{4}{l}{\lst{end def}} \\
    \hline
    \hline
\end{tabularx}\)
\end{figure}

\subsubsection{SigmaProp serialization}
\label{sec:ser:data:sigmaprop}

\begin{figure}[H] \footnotesize
\caption{SigmaProp serialization format}\vspace{-7pt}
\label{fig:ser:data:sigmaprop}
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    \hline
\end{tabularx}\)
\end{figure}

\subsubsection{Box serialization}
\label{sec:ser:data:box}

\begin{figure}[H] \footnotesize
\caption{Box serialization format}\vspace{-7pt}
\label{fig:ser:data:box}
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    \hline
\end{tabularx}\)
\end{figure}

\subsubsection{AvlTree serialization}
\label{sec:ser:data:avltree}

\begin{figure}[H] \footnotesize
\caption{AvlTree serialization format}\vspace{-7pt}
\label{fig:ser:data:avltree}
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    \hline
\end{tabularx}\)
\end{figure}
