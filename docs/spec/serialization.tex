\section{Serialization}
\label{sec:serialization}

This section defines a binary format, which is used to store \langname
contracts in persistent stores, to transfer them over the wire and to enable
cross-platform interoperation.

Terms of the language described in Section~\ref{sec:language} can be
serialized to array of bytes to be stored in Ergo blockchain (e.g. as
\lst{Box.propositionBytes}).

When the guarding script of an input box of a transaction is validated the
\lst{propositionBytes} array is deserialized to an \langname IR (represented by the
\lst{ErgoTree} class), which can be evaluated as it is specified in
Section~\ref{sec:evaluation}.

Here we specify the serialization procedure in general. The serialization format of
\langname types (\lst{SType} class) and nodes (\lst{Value} class) is specified in
section~\ref{sec:ser:type} and Appendix~\ref{sec:appendix:ergotree_serialization}
correspondingly.

Table~\ref{table:ser:limits} shows size limits which are checked during
contract deserialization, which is important to resist malicious script attacks.

\begin{table}[h]
    \footnotesize
\(\begin{tabularx}{\textwidth}{| l | p{2.5cm} | X |}
    \hline
    \bf{Name}   & \bf{Value} & \bf{Description} \\
    \hline
    $\MaxVlqSize$  & $10$ & Maximum size of VLQ encoded byte sequence (See VLQ formats~\ref{sec:vlq-encoding})  \\
    \hline
    $\MaxTypeSize$ & $100$ & Maximum size of serialized type term (see Type format~\ref{sec:ser:type}) \\
    \hline
    $\MaxDataSize$ & $10Kb$ & Maximum size of serialized data instance (see Data format~\ref{sec:ser:data}) \\
    \hline
    $\MaxConstSize$ & $=\MaxTypeSize+\MaxDataSize$  & Maximum size of serialized data instance (see Const format~\ref{sec:ser:const}) \\
    \hline
    $\MaxExprSize$ & $4Kb$ & Maximum size of serialized \langname term (see Expr format~\ref{sec:ser:expr}) \\
    \hline
    $\MaxErgoTreeSize$ & $4Kb$ & Maximum size of serialized \langname contract (see ErgoTree format~\ref{sec:ser:ergotree}) \\
    \hline
\end{tabularx}\)
\caption{Serialization limits}
\label{table:ser:limits}
\end{table}

All the serialization formats which are uses and defined thoughout this section are
listed in Table~\ref{table:ser:formats} which introduces a name for each format and also
shows the number of bytes each format may occupy in the byte stream.

\begin{table}[h]
    \scriptsize
\(\begin{tabularx}{\textwidth}{| l | l | X |}
    \hline
    \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    \lst{Byte} & $1$ & 8-bit signed two's-complement integer \\
    \hline
    \lst{Short} & $2$ & 16-bit signed two's-complement integer (big-endian) \\
    \hline    
    \lst{Int} & $4$ & 32-bit signed two's-complement integer (big-endian) \\
    \hline
    \lst{Long} & $8$ & 64-bit signed two's-complement integer (big-endian) \\
    \hline
    \lst{UByte} & $1$ & 8-bit unsigned integer \\
    \hline
    \lst{UShort} & $2$ & 16-bit unsigned integer (big-endian) \\
    \hline    
    \lst{UInt} & $4$ & 32-bit unsigned integer (big-endian) \\
    \hline
    \lst{ULong} & $8$ & 64-bit unsigned integer (big-endian) \\

    \hline
    \lst{VLQ(UShort)} & $[1..3]$ & Encoded unsigned \lst{Short} value using VLQ. See~\cite{VLQWikipedia,VLQRosetta} and~\ref{sec:vlq-encoding} \\
    \hline    
    \lst{VLQ(UInt)} & $[1..5]$ & Encoded unsigned 32-bit integer using VLQ. \\
    \hline
    \lst{VLQ(ULong)} & $[1..\MaxVlqSize]$ & Encoded unsigned 64-bit integer using VLQ. \\

    \hline
    \lst{Bits} & $[1..\MaxBits]$ & A collection of bits packed in a sequence of bytes. \\
    \hline
    \lst{Bytes} & $[1..\MaxBytes]$ & A sequence of bytes, which size is stored elsewhere or wellknown. \\

    \hline
    \lst{Type} & $[1..\MaxTypeSize]$ & Serialized type terms of \langname. See~\ref{sec:ser:type} \\
    \hline
    \lst{Data} & $[1..\MaxDataSize]$ & Serialized \langname values. See~\ref{sec:ser:data} \\
    \hline
    \lst{GroupElement} & $33$ & Serialized elements of eliptic curve group. See~\ref{sec:ser:data:groupelement} \\
    \hline
    \lst{SigmaProp} & $[1..\MaxSigmaProp]$ & Serialized sigma propositions. See~\ref{sec:ser:data:sigmaprop} \\
    \hline
    \lst{Box} & $[1..\MaxBox]$ & Serialized box data. See~\ref{sec:ser:data:box} \\
    \hline
    \lst{AvlTree} & $44$ & Serialized dynamic dictionary digest. See~\ref{sec:ser:data:avltree} \\
    \hline
    \lst{Const} & $[1..\MaxConstSize]$ & Serialized \langname constants (values with types). See~\ref{sec:ser:const} \\
    \hline
    \lst{Expr} & $[1..\MaxExprSize]$ & Serialized expression terms of \langname. See~\ref{sec:ser:expr} \\
    \hline
    \lst{ErgoTree} & $[1..\MaxErgoTreeSize]$ & Serialized instances of \langname contracts. See~\ref{sec:ser:ergotree} \\
    \hline
\end{tabularx}\)
\caption{Serialization formats}
\label{table:ser:formats}
\end{table}

We use $[1..n]$ notation when serialization may produce from 1 to n bytes depending of
actual data instance.

Serialization format of \ASDag is optimized for compact storage and very fast
deserialization. In many cases serialization procedure is data dependent and thus have
branching logic. To express this complex serialization logic in the specification we
use a \emph{pseudo-language} with operators like \lst{for, match, if, optional}. The
language allows to specify a \emph{structure} out of \emph{simple serialization slots}.
Each \emph{slot} specifies a fragment of serialized stream of bytes, whereas
\emph{operators} specifiy how the slots are combined together to form the resulting
stream of bytes.

In the next section we describe how types (like \lst{Int}, \lst{Coll[Byte]},
etc.) are serialized, then we define serialization of typed data. This will
give us a basis to describe serialization of Constant nodes of \ASDag. From
that we will proceed to serialization of arbitrary \ASDag trees.

\input{type_serialization.tex}

\input{data_serialization.tex}


\subsection{Constant Serialization}
\label{sec:ser:const}

\lst{Constant} format is simple and self sufficient to represent any data value in
\langname. Every data block of \lst{Constant} format contains both type and
data, such it can be stored or wire transfered and then later unambiguously
interpreted. The format is shown in Figure~\ref{fig:ser:const}

\begin{figure}[h]
\footnotesize
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    $type$  & \lst{Type} & $[1..\MaxTypeSize]$ & type of the data instance (see~\ref{sec:ser:type}) \\
    \hline
    $value$  & \lst{Data} & $[1..\MaxDataSize]$ & serialized data instance (see~\ref{sec:ser:data}) \\
    \hline
\end{tabularx}\)
\caption{Constant serialization format}
\label{fig:ser:const}
\end{figure}

\subsection{Expression Serialization}
\label{sec:ser:expr}

Expressions of \langname are serialized as tree data structure using
recursive procedure described here. 

\begin{figure}[h]
\footnotesize
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    \multicolumn{4}{l}{\lst{def serializeExpr(}$e$\lst{)}} \\
    \hline
    ~~$e.opCode$  & \lst{Byte} & $1$ & opcode of ErgoTree node, 
    used for selection of an appropriate node serializer from Appendix~\ref{sec:appendix:ergotree_serialization} \\
    \hline
    \multicolumn{4}{l}{~~\lst{if} $opCode <= LastConstantCode$ \lst{then}} \\
    \hline
    ~~~~$c$  & \lst{Const} & $[1..\MaxConstSize]$ & Constant serializaton slot \\ 
    \hline
    \multicolumn{4}{l}{~~\lst{else}} \\
    \hline
    ~~~~$body$  & Op & $[1..\MaxExprSize]$ & serialization of operation arguments 
    depending on $e.opCode$ as defined in Appendix~\ref{sec:appendix:ergotree_serialization} \\ 
    \hline
    \multicolumn{4}{l}{~~\lst{end if}} \\
    \multicolumn{4}{l}{\lst{end serializeExpr}} \\
    \hline
\end{tabularx}\)
\caption{Expression serialization format}
\label{fig:ser:expr}
\end{figure}


\subsection{\ASDag~serialization}
\label{sec:ser:ergotree}

The root of a serializable \langname term is a data structure called \ASDag
which serialization format shown in Figure~\ref{fig:ergotree}

\begin{figure}[h]
\footnotesize
\(\begin{tabularx}{\textwidth}{| l | l | l | X |}
  \hline
  \bf{Slot} & \bf{Format} & \bf{\#bytes} & \bf{Description} \\
  \hline
  $ header $ & \lst{VLQ(UInt)} & [1, *] & the first bytes of serialized byte array which
  determines interpretation of the rest of the array \\
  \hline
  $numConstants$ & \lst{VLQ(UInt)} & [1, *] & size of $constants$ array \\
  \hline
  \multicolumn{4}{l}{\lst{for}~$i=1$~\lst{to}~$numConstants$} \\
  \hline
      ~~ $ const_i $ & \lst{Const} & [1, *] & constant in i-th position \\
  \hline
  \multicolumn{4}{l}{\lst{end for}} \\
  \hline
  $ root $ & \lst{Expr} & [1, *] & If constantSegregationFlag is true, the  contains ConstantPlaceholder instead of some Constant nodes.
                       Otherwise may not contain placeholders.
                       It is possible to have both constants and placeholders in the tree, but for every placeholder
                       there should be a constant in $constants$ array. \\
  \hline
\end{tabularx}\)
\caption{\ASDag serialization format}
\label{fig:ser:ergotree}
\end{figure}


Serialized instances of \ASDag are self sufficient and can be stored and passed around.
\ASDag format defines top-level serialization format of \langname scripts.
The interpretation of the byte array depend on the first $header$ bytes, which uses VLQ encoding up to 30 bits.
Currently we define meaning for only first byte, which may be extended in future versions.

\begin{figure}[h]
    \footnotesize
\(\begin{tabularx}{\textwidth}{| l | l | X |}
    \hline
    \bf{Bits} & \bf{Default Value} & \bf{Description} \\
    \hline
    Bits 0-2 & 0 & language version (current version == 0) \\
    \hline
    Bit 3 & 0 & reserved (should be 0) \\
    \hline
    Bit 4 & 0 & == 1 if constant segregation is used for this ErgoTree (see~ Section~\ref{sec:ser:constant_segregation}\\
    \hline
    Bit 5 & 0 & == 1 - reserved for context dependent costing (should be = 0) \\
    \hline
    Bit 6 & 0 & reserved for GZIP compression (should be 0) \\
    \hline
    Bit 7 & 0 & == 1 if the header contains more than 1 byte (should be 0) \\
    \hline
\end{tabularx}\)
\caption{\ASDag $header$ bits}
\label{fig:ergotree:header}
\end{figure}

Currently we don't specify interpretation for the second and other bytes of
the header. We reserve the possibility to extend header by using Bit 7 == 1
and chain additional bytes as in VLQ. Once the new bytes are required, a new
version of the language should be created and implemented via
soft-forkability. That new language will give an interpretation for the new
bytes.

The default behavior of ErgoTreeSerializer is to preserve original structure
of \ASDag and check consistency. In case of any inconsistency the
serializer throws exception.

If constant segregation bit is set to 1 then $constants$ collection contains
the constants for which there may be \lst{ConstantPlaceholder} nodes in the
tree. If is however constant segregation bit is 0, then \lst{constants}
collection should be empty and any placeholder in the tree will lead to
exception.

\subsection{Constant Segregation}
\label{sec:ser:constant_segregation}

