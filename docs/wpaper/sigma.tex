\documentclass[11pt]{article}

\def\shownotes{1}
\def\notesinmargins{0}

\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array}


\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{blue}{morphic notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{$\Sigma$-State}
\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}
\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}

\title{\langname, an Alternative to Bitcoin Script}

%\author{Leonid Reyzin\inst{1,3}, Dmitry Meshkov\inst{2}, Alexander Chepurnoy\inst{2}}

%\institute{Boston University \\\email{reyzin@bu.edu} \and
%IOHK Research \\\email{\{dmitry.meshkov,alex.chepurnoy\}@iohk.io} \and


\maketitle


\begin{abstract}
We report on design and implementation of \langname, a more powerful, protocol-friendly and at the same more secure language than the  Script language used in Bitcoin. We provide some examples of scripts in the language.
\end{abstract}



\section{Introduction}
\paragraph{Background}
Since its early days, Bitcoin~\cite{Nak08} has allowed more than simple money transfers between two public keys: its Bitcoin Script scripting language has allowed participants to specify conditions for how money could be spent. A program written in Bitcoin Script is attached to every transaction output (i.e., amount received); this program protects the transaction by determining how the transaction output can be used as an input to (i.e., spent in) a future transaction. The simplest condition is specified by a program that contains the recipient's public key and states that the money can be spent by creating a signature that verifies under this key.  However, more general conditions are allowed by more sophisticated programs. 

The Bitcoin Script language is a primitive stack-based language without loops. To spend an output protected by a program, a spending transaction must provide a program in the same language, and the concatenation of the two programs must evaluate to \emph{true}. The creator of the spending transaction can be viewed as a prover (for example, proving knowledge of the secret key by producing a signature), where the statement that needs to be proven is specified by the output that is being spent. Transaction validity is verified by executing programs. Bounded validation time is ensured by the absence of loops in the programming language and a maximum program size of 10 kilobytes. Even so, some denial-of-service attacks exploiting script validation time have appeared. \knote{links} On the other hand, the deliberate simplicity of the programming language limits the kinds of contracts that can be created on the Bitcoin platform.

To allow for more sophisticated ``smart'' contracts, Ethereum allows for arbitrary Turing-complete programs. This approach requires charging for computation in order to prevent denial-of-service attacks, because the running time of a Turing-complete program cannot, in general, be estimated without actually running the program.


\paragraph{Our Contribution}
In this paper we introduce a new language that is specifically designed to be friendly to cryptographic protocols and applications. The language is considerably more powerful than Bitcoin Script, but it is not Turing-complete. Given a program in our language, it is easy to obtain a bound on its running time. \knote{continue}

\lnote{it would be good to name the language --- named designs are easier for people to remember and will get more recognition eventually}

Our new language incorporates proving and verifying as first-class primitives, giving developers to a subclass of cryptographic proof systems known as non-interactive $\Sigma$-protocols (pronounced ``sigma-protocols'').   Thus, the output of a transaction contains a statement that needs to be proven in order to spend this output. 

Conceptually, $\Sigma$-protocols protocols are generalizations~\cite{CL06} of signature schemes.
In fact, Schnorr signature scheme~\cite{Sch91} (whose more recent version is popularly known as EdDSA \cite{BDLSY12,rfc8032}) is the canonical example of a non-interactive $\Sigma$-protocol: it proves that the recipient knows the discrete logarithm of the public key (the proof is attached to a specific, such as a particular transaction, and thus becomes a signature on the message; all $\Sigma$-protocols described here can be attached to specific messages). $\Sigma$-protocols exist for proving a variety of properties and, importantly for our language, elementary $\Sigma$-protocols can be combined into more sophisticated ones.
 See \lnote{damgard's notes \url{http://www.cs.au.dk/~ivan/Sigma.pdf}? anything better?} for an introduction to $\Sigma$-protocols. \lnote{should we also point to Cramer's thesis or anything else?}

Specifically for our language, we provide two elementary $\Sigma$-protocols over a group of prime order (such as an elliptic curve), written here in multiplicative notation:
\begin{itemize}
\item A proof of knowledge of discrete logarithm (i.e., a Schnorr signature): given the group generator $g$ and a group element $h$, the proof convinces a verifier that the prover knows $w$ such that $h=g^w$, without revealing $w$
\item A proof that of equality of discrete logarithms (i.e., a proof of a Diffie-Hellman tuple): given group elements $g, h, u, v$, the proof convinces a verifier that the prover knows $w$ such that $u=g^w$ and $v=h^w$, without revealing $w$
\end{itemize}
\lnote{I don't like the notation above -- $g$ is overloaded because it's the base point in item 1 and an arbitrary point in item 2; $h$ is also overloaded. However, this is the notation used in the code. I would like to think of better notation and have the white paper match the code.}


We also provide the ability to build more sophisticated $\Sigma$-protocols by using $\andnode$ and $\ornode$ connectives \lnote{add $\tnode$ when we implement it}. Crucially, the proof for an $\ornode$ connective does not reveal which of the relevant values the prover knows: for example, in our language a ring signature by public keys $h_1, \dots, h_k$ can be specified as an $\ornode$ of $\Sigma$-protocols for proving knowledge of discrete logarithms of $h_1, \dots, h_k$. The proof can be constructed with the knowledge of just one such discrete logarithm, and does not reveal which one was used in its construction. 

In addition to $\Sigma$-protocols, our language allows for predicates over the state of the blockchain. These predicates can be combined, via Boolean connectives, with $\Sigma$-protocol proofs, and are used during transaction validation. The set of predicates is richer than in Bitcoin, but still lean in order to allow for efficient processing even by light clients. Like in Bitcoin, we allow the use of current height of the blockchain; unlike Bitcoin, we also allow the use of information contained in the spending transaction, such as inputs it is trying to spend and outputs it is trying to create. Also unlike Bitcoin, we allow outputs to contain fields in addition to the amount and protecting script \lnote{how can these be accessed? it's not clear to me.} The language is statically typed (with compile-time type checking) and allows the usual operations, such as integer arithmetic.



\lnote{Old intro text below this line. Not sure if any needs to be kept -- I think I got most of its points above}

------------------------------------------------------

Much like digital signatures prove that the signer knows the secret key, $\Sigma$-protocols can be used to prove knowledge of a discrete logarithm. 


The idea behind the language is that a subset of zero-knowledge protocols known as $\Sigma$-protocols (sigma protocols) could be combined via $\sqcap$ and $\sqcup$ connectives forming complex statements like ``prove me a knowledge of discrete logarithm of (publicly known) $x_1$ or knowledge of Pedersen commitment $x_2$ preimage''. We make an observation that sigma protocol statements and their conjectures are naturally correspond to propositional logic, and we can add arbitrary boolean predicates to statements provable via a $\Sigma$-protocol, if both prover and verifier are able to evaluate the predicates in exactly the same way. This is the case if predicates are evaluated deterministically in the same way by both the prover and the verifier, and inputs for the predicates are the same on both sides.
We assume prover and verifier can be different parties, e.g. prover is a creator of transactions (wallet application) and verifier is a miner validating incoming transactions.
We use predicates over state of blockchain system during script validation~(which happens when a transaction tries to spend an output protected by the script). To avoid inefficient processing and impossibility for a light client to validate a transaction, this state is very lean but nevertheless it is richer than in Bitcoin. Like in Bitcoin, we use current height of the blockchain, but also a spending transaction with outputs it creates and inputs it tries to spend. Unlike Bitcoin, we allow outputs to contain more fields than amount and protecting script, in a form of additional registers an output can have. In addition to $\land$ and $\lor$ connectives for boolean propositions we also introduce $\sqcap$ and $\sqcup$ connectives for sigma protocol statements. The language also have different operations over statically typed arguments. We reject out during compilation time expressions with type errors, like $2 + 2 > true$, thanks to a type system used.

In blockchain systems, there is a strict need to tackle the problem of denial-of-service attack carrying by crafting scripts which are too costly to validate. For example, if it is needed for more time to validate a script than average delay between blocks on commodity hardware, network could be obviously attacked, with nodes stuck in processing, and also increased number of forks as result. 

------------------------------------------------------


\lnote{I think here we should put a few examples to help the reader get an idea, and then point fo more examples below in the paper}

\section{Related Work}

\knote{A good survey is available at https://arxiv.org/pdf/1801.00687.pdf, pg. 11}

\begin{itemize}
    \item{Simplicity}
    \item{Plutus}
    \item{TypeCoin}
    \item{Rholang}
\end{itemize}


\section{Language Design}

We assume that a {\em prover} and a {\em verifier} have a shared {\em context}. As we are designing a language for cryptocurrencies, the context is about current state of the blockchain (such as height $h$ of a best block in the blockchain, a spending transaction with outputs it spends and newly created outputs, etc). Please note that the language can be repurposed for other areas where shared context is possible, but this is out of scope of the paper.

\subsection{Notation}

We use $Dlog(x)$ to denote a statement ``prove a knowledge of such $w$ that $x = g^w$''. Proving is to be done by a prover in zero knowledge~(with no presenting the secret $w$ to a verifier). Statement $Dlog(x_1) \sqcap Dlog(x_2)$ means ``prove a knowledge of both $w_1$ and $w_2$, such as $x_1 = g^{w_1}, x_2 = g^{w_2}$'', similarly, $Dlog(x_1) \lor Dlog(x_2)$ is about a proof of knowledge of either $w_1$ or $w_2$.

\subsection{UTXO model}

We assume a transactional model close to Bitcoin's. That is, a transaction spends unspent outputs (pointed to by \emph{transaction inputs}) from previous transaction written into the blockchain, and creates new outputs. An output is associated with arbitrary amount of money, and also a protecting script. In Bitcoin, there is a special kind of transaction, so-called {\em coinbase transaction}, which can create some amount of money out of thin air~(to reward a block generator). In Bitcoin transaction fees money flow is not captured in outputs, a transaction fee is just a difference of amounts of outputs being spent and outputs being created. In Appendix~\ref{apx:unified} we provide a way to avoid coinbase transactions, and also express fees explicitly as outputs. In Appendix~\ref{apx:account} we discuss how to make a language for a cryptocurrency with account-based transactions~(such as Waves~\cite{Waves}).

\subsection{Logic of $\Sigma$-protocols}

Cryptocraphic propositions verifiable via $\Sigma$-protocols are represented by values of an algebraic data type $SigmaProp$,
which stands for \emph{sigma proposition} and can be described using the following declaration (using Idris/Agda ADT notation~\cite{Idris, Agda})

\begin{lstlisting}
data SigmaProp: Type where
  Dlog: GroupElement -> SigmaProp
  Dht: (gv, hv, uv, vv: GroupElement) -> SigmaProp
  ...
\end{lstlisting}

In the definition above, each constructor represents one of the cryptographic primitives, and the set of such constructors
can be extended (although this extensibility is out of paper's scope).

We want to be able to construct more complex statements out of basic primitive propositions.
There are two binary operations over $SigmaProp$ values:
\begin{itemize}
\item $\sqcup: (SigmaProp, SigmaProp) -> SigmaProp$
\item $\sqcap: (SigmaProp, SigmaProp) -> SigmaProp$
\end{itemize}

Any expression of $SigmaProp$ type can be efficiently verified using sigma protocol and thus mapped to a truth values.

We implement a verification procedure $V: Sigma -> Boolean$, which performs such mapping, and satisfies the following
naturality conditions with respect to Sigma and Boolean connectives.

For any two statements $sigma1, sigma2: Sigma$:
\begin{itemize}
    \item $V(s_1 \sqcup s_2) = V(s_1) \lor V(s_2)$
    \item $V(s_1 \sqcap s_2) = V(s_1) \land V(s_2)$
\end{itemize}

Bacause Sigma connectives and logical connectives satisfy naturality conditions we can reason about complex sigma statements
the same way we reason about logical statements.
However, unlike logical statements evaluation of sigma statements is done with zero knowledge about intermediate steps.
Thus, we can verify the truth of $s_1 \sqcup s_2$ (i.e. compute $V(s_1 \sqcup s_2)$) statement but we cannot know whether $s_1$ or $s_2$ or both is true. At the same time evaluation of $V(s_1) \lor V(s_2)$ discloses results of both $V(s_1)$ and $V(s_2)$ before execution of $\lor$.

There is a function $isValid: Sigma -> Boolean$ in Sigma-state language which implements the function $V$.
The type system of the language allows to explicitly delimit usages of zero knowledge evaluation
of sigma statements and classical evaluation of boolean statements.

This allows script designer to explicitly control security (zero-knowledge) guarantees where it is necessary.

\subsection{General Idea}

By using a $\Sigma$-protocol, a prover can prove a knowledge of secret information corresponding to publicly known values, in zero-knowledge(i.e. without disclosing a secret value), for some relations between secret and public values. Unlike generic proof systems, $\Sigma$-protocols are efficient~(for both the prover and the verifier). For a cryptocurrency setting, the pros of this class of protocols are generic transformation from an interactive protocol to non-interactive one~(by using Fiat-Shamir transformation), and also composability: we can combine statements provable with $\Sigma$-protocols via $\land$, $\lor$ and k-out-of-N conjectures, and the compound statement is also provable via a $\Sigma$-protocol. An observation which is lying in the foundation of our work is that we can view a (potentially complex) statement provable via a $\Sigma$-protocol as a formula over sigma values homomorphic to logical formula. For example, the statement $dlog(x_1) \lor dlog(x_2)$ could be viewed as a formula consisting of two sigma values connected by $\lor$ and which is homomorphic to the formula $b1 or b2$. Then we can enrich the language of $\Sigma$-protocols (which describes relations between prover's secrets and their publicly known images) with deterministic predicates over a context shared between the prover and the verifier. Still, we are using only $\land$, $\lor$ and k-out-of-N conjectures. By evaluating predicates over the context into concrete boolean values and then eliminating them, both (honest) the prover and verifier do agree on the same reduction procedure output, which could be one of the following: boolean value (true or false) or a statement provable via a $\Sigma$-protocol. However, in the light of denial-of-service attacks found against scripting capabilities of Bitcoin and Ethereum \knote{todo: links}, we need to limit possible complexity of the reduction procedure. For that, we have two measures against possible overload issues. In the first place, we have to use only context which is efficiently computable. For example, we can not have predicates over transactional history, as it is linearly growing with time, and also could not be hold by a light client. In opposite, we can use height of a block which contains the transaction spending the output of interest, access to this information is constant-time and available to light clients. If a validation state~(which is similar to UTXO set in Bitcoin for Bitcoin-like cryptocurrencies) is authenticated~(like proposed in the paper \knote{cite AVL paper}), we can construct a predicate for existence of an unspent output (with some conditions to be met), then the prover is providing a Merkle proof for an output satisfying the predicate, and even a light client can validate the predicate efficiently. In the second place, we put a limit on size of an initial logic formula which protects an output, and also we take care that the formula will not become too big due rewritings (as some transformations in our proposal could actually increase a size of the formula\mnote{For example? Looks like all the transforms are decreasing.}) and number of transformations is below an upper limit.

\subsection{Model}

An output to spend is protected by a logical expression, which we are also calling a {\em guarding expression}. An expression is a mix of predicates over publicly known context, and statements provable via sigma protocols. As a simplest example, consider the following statement:

\begin{equation}
\label{eq:example1}
dlog(x_1) \lor ((h > 5) \land dlog(x_2))
\end{equation}

which is to be read as ``proof of knowledge of a secret with public image $x_1$ is always enough, also, if height of a block containing spending transaction is more than 5, knowledge of a secret with public image $x_2$ is also enough'' to admit spending of the output.

Both the prover and the verifier are first reducing the statement by substituting shared context variables and evaluating parts of the expression which are possible to evaluate. Four outcomes of the reduction process are possible: {\em true}, {\em false}, failure to reduce~(if statement is invalid, or transformations of it are taking too much time or result in unreasonably big statement), which is equivalent to {\em false}; or statement which contains only cryptographic statements. For the example, if $h = 10$, the reduced statement is $dlog(x_1) \lor dlog(x_2)$. In this case, the prover is generating a proof, and verifier is checking validity of the proof, accepting or rejecting it. We use cryptographic statements which are provable via {\em sigma protocols}~(\knote{links}). These protocols are efficient zero-knowledge \knote{special honest verifier ZK actually} proof-of-knowledge protocols which are composable via $\land$, $\lor$ and k-out-of-N conjectures, also any sigma protocol has a standard way to be converted into a signature by using the Fiat-Shamir transformation. 

In addition to secret information, which knowledge is to be proven in zero-knowledge, we allow prover to enhance context with custom variables. For example, for the statement:

$$dlog(x) \land (blake2b256(c) = C)$$

where $C$ is some constant~\footnote{we avoid providing a value for the constant due to column size limit}, and $blake2b256$ is operation which calculates hash value for function Blake2b256~(\knote{link}). The prover then needs to prove knowledge of discrete logarithm of $x$ and also to present value $c$ such as Blake2b256 on $c$ evaluates to $C$. Even if verifier does not know $c$ before being presented a proof, we can not count $c$ as secret, as it could be replayed by an eavesdropper.



\subsection{Language Details} 
\label{sec:lang-details}

Here we provide details on building blocks of the language.  
Both the prover and the verifier are doing the same first few steps, and they both are using the same deterministic interpreter. In the first place, the interpreter is parsing incoming expression~(in typical case of validating a transaction within a block, it is encoded in a binary form), building a tree from the expression, and checking that the expression is well-formed according to typing rules. We describe types and typing rules in Section~\ref{sec:types}. The interpreter then is reducing the expression by applying rewriting rules to the tree as described in the Section~\ref{sec:rewriting}. The possible result of the reduction is whether an abort, or a successfully reduced expression, which could be whether a boolean value or a statement provable via a $\Sigma$-protocol. For the latter case, the prover and the verifier are doing different jobs: the prover is proving knowledge of secrets associated with the statement, as described in Section~\ref{sec:proving}; the verifier is checking a proof generated by the prover against the statement, as described in the Section~\ref{sec:verifying}.   

The interpreter is also checking that the expression is not exceeding by number of sub-expressions and their cumulative complexity some predefined limit~(which is the same for the prover and the verifier, e.g a constant of a blockchain system, or changed by miners in predictable and controllable fashion, like gas limit per block in Ethereum). As complexity is going beyond the limit, the interpreter aborts immediately. 


\subsection{Types}
\label{sec:types}

All the operations as well as operands have types. For example, addition operation ``+'' may take two Int and returns an Int value. Comparison operation ``$>$'' takes two Int and returns a boolean value. Some operations may be overloaded so that the same symbol is reused for operations acting on different types, e.g. $+: (Int,Int) \to Int$, $+: (Long, Long) \to Long$ etc.
We consider statements provable via $\Sigma$-protocols, like $dlog(x)$ as instances of the boolean type. The interpreter checks that all the nodes in the tree have children of appropriate types, and the whole guarding expression~(the root node of the tree) has a boolean type and rejects the expression if the conditions are not met.

We have following types in the language:

\begin{itemize}
    \item{signed integer types of 8, 16, 32 and 64-bits size}
    \item{big integer type of arbitrary size}
    \item{boolean}
    \item{avl+ tree verification data}
    \item{cryptography group element}
    \item{box}
    \item{tuple of values of different types}
    \item{array of values of the same type}
    \item{optional value}
\end{itemize}

\knote{todo: improve description, also, add unsigned integer?}

\ignore{
\begin{center}
    \begin{tabular}{| l | l | l | l | l |}
    \hline
    Operation & bytes & ints & prop & bool \\ \hline
    $=$ & + & + & + & + \\ 
	$\neq$ & + & + & + & +\\ 
	$+$ & + & + & - & - \\    
	$-$ & - & + & - & - \\
	$>$ & - & + & - & - \\
	$\ge$ & - & + & - & -\\
	$<$ & - & + & - & -\\
	$\le$ & - & + & - & -\\
	$\oplus$ & + & - & - & + \\
	$\lor$ & - & - & - & + \\
	$\land$ & - & - & - & + \\
	$blake2b256$ & + & - & - & -\\
	$dlog$ & - & - & - & -\\
	$dh$ & - & - & - & -\\
    \hline
    \end{tabular}
\end{center}
}


\subsection{Rewriting a Tree}
\label{sec:rewriting}

By parsing a statement, interpreter first builds a tree from a formula. For the example~\ref{eq:example1} the tree would be as following:

\knote{draw the tree}.

If the tree is well-formed according to the typing rules, and also has complexity no more than an allowed limit, interpreter is going to rewrite it, in potentially many steps. For every step, the interpreter tries, going from bottom to top of the tree, to replace nodes which are ready to be transformed~(operands are in place, and the transformation itself is known). The next step is about the same transformations in the same bottom-top order to be done. The process finishes in one of the following cases:

\begin{itemize}
    \item{abort: } happens if transformation process by its complexity exceeds an upper bound. The complexity estimation works as follows. The interpreter remembers initial cumulative complexity $C_0$, and for each replacement in the tree it calculates cumulative complexity of a subtree to be inserted instead of a subtree to be removed $\Delta C$, and adds $\Delta C$ to current cumulative complexity $C$, where $C = C_0$ initially.  
    \item{success: } we finish with this status if during last step there are no any transformations done.  
\end{itemize} 

If the transformations are finishing with abortion, the result is considered as $false$ (we recall that the interpreter is giving a single boolean result finally, whether an output could be spent or not). Otherwise, if the tree could not be transformed anymore the interpreter is looking into it. If the tree is about just a single node which contains boolean constant value~($true$ or $false$), the value is the result of the interpretation. If the tree contains statements not provable via $\Sigma$-protocols, the interpreter finishes with $false$. Otherwise, if the tree contains only statements provable via $\Sigma$-protocols, the interpreter is continuing to work, and here execution is different for the prover and the verifier. The prover is generating a proof for the statement by using its secrets, as described in Section~\ref{sec:proving}, and the verifier checks the statement against the proof~(provided in a spending transaction), as described in Section~\ref{sec:verifying}. The verifier outputs $true$ if the proof is valid for the statement, $false$ otherwise. We are skipping for now the question how Fiat-Shamir transformation works in our setting, and how a message, which is used in a non-interactive protocol is formed; details are given further in Appendix~\ref{apx:tx-format}. 



\section{Context}

Shared context of a blockchain system could be expressed in different ways, based on desired expressiveness, efficiency, planned use cases and so on. In this paper we focus on context for Ergo blockchain. The main priority for this blockchain is maximum efficiency of transaction validation process, safety, and friendliness to light clients. Considering this, we require that context should contain only spending transaction along with outputs it spends, and limited number of last block headers. Thus even a client which does not have all the headers of the blockchain~(for example, the client could be working in a light-SPV mode, where the client is holding only sublinear part of the headers-chain) is able to validate a transaction, by being shown it~(as well as outputs the transaction spends along with Merkle proofs for them).

\knote{brief context description, link to an appendix with details}



\section{Details of $\Sigma$-protocols for an arbitrary And/Or/Threshold composition}
\subsection{Background}

\lnote{need to give some references that explain $\Sigma$-protocols well. Not sure what --- may need to dig through the literature}

In this section, we explain in detail how the $\Sigma$-protocol proving and verifying is implemented. Consider the tree after the rewriting process, as described in Section~\ref{sec:rewriting}, reduces to only $\Sigma$-protocol nodes. Then the leaves of the tree are atomic $\Sigma$-protocols, and non-leaves are of one of three types: $\andnode$, $\ornode$, or $\tnode(k)$. \lnote{connect these types to what's described above}

The meaning of the proof corresponding to $\tnode(k)$ is ``the prover knows witnesses for at least $k$ children of this node''. Semantically, $\andnode$ and $\ornode$ are simply special cases of $\tnode$: the meaning  of the proof corresponding $\andnode$ (respectively, $\ornode)$ is ``the prover knows witnesses for all children (respectively, at least one child) of this node''. However, $\andnode$ and $\ornode$ are implemented differently from $\tnode$ for efficiency.

For the purposes of this description, it does not matter what specific atomic $\Sigma$-protocols are used at the leaves. They can be, for example, $Dlog(x)$ for proving knowledge of the discrete logarithm $w$ of $x=g^w$, or $DH(g, x, h, y)$ for proving that $(g, x, h, y)$ form a Diffie-Hellman tuple, i.e., $(\exists w) \ x = g^w \, \wedge \, y = h^w$. In general, we will assume the prover has some secret $w$ and wants to prove some property of it. 

A $\Sigma$-protocol consist of three messages: 

\begin{itemize}
\item a \emph{commitment} $a$ sent from the Prover to the Verifier (computed using $w$ and some freshly generated secret randomness $r$ by the Prover's first step algorithm);
\item a uniformly random \emph{challenge} $e$ sent from the Verifier to the Prover;
\item and a \emph{response} $z$ sent from the Prover to the Verifier (computed using $w$, $e$, and $r$ by the Prover's second step algorithm). 
\end{itemize}
The verifier then checks that the triple $(a, e, z)$ satisfies some formula and, if so, accepts the proof.

In order to make an atomic $\Sigma$-protocol non-interactive using the so-called Fiat-Shamir heuristic, the Prover would compute $e$ by hashing $a$, and the Verifier would check that $e$ is indeed a hash of $a$. However, once atomic $\Sigma$-protocols are composed using $\andnode$, $\ornode$, and $\tnode$, the challenge computation becomes more involved, as we describe below.

$\Sigma$-protocols have the property of \emph{special honest-verifier zero-knowledge}. For the purposes of this description, it means that given a random $e$, it is possible to compute $a$ and $z$ without knowing the secret $w$ that is normally needed by the prover. This computation is called ``simulation''. Moreover, the triple $(a, e, z)$  computed via simulation is distributed identically to the triple $(a, e, z)$ that results form a $\Sigma$ protocol that is run by the honest prover (who knows the secret $w$) and verifier (who generates a uniform $e$). The trick that makes simulation possible is that the response $z$ is chosen by the simulator before commitment $a$, in contrast to the prover, who is forced to choose $a$ before $z$.

$\Sigma$-protocols used in this work must also satisfy a property of \emph{special soundness}, which means that given two triples $(a_1, e_1, z_1)$ and $(a_2, e_2, z_2)$ that are both accepted by the verifier, and $a_1=a_2$ while $e_1\neq e_2$, it is possible to compute the Prover's secret $w$ in polynomial time and thus directly verify that the statement claimed by the Prover is true.   Note that this computation is never performed, because the Prover will never actually answer two different challenges $e_1\neq e_2$ for the same commitment $a_1=a_2$. 

In order for composition of $\Sigma$-protocols using $\andnode$, $\ornode$, and $\tnode$ to work, the challenge $e$ in all protocols must be a binary string of the same length, which we will call $t$.  (This implies that if the Verifier performs arithmetic modulo $q$ on $e$, then $2^t<q$; else it would be trivial to have $e_1\neq e_2$ by letting $e_2=e_1+q$, and the same $z$ would work for both $e_1$ and $e_2$, violating the special soundness property mentioned above, because such $a, e_1, z$ can be computed without knowledge of $w$ by using the simulator.)  Note that $t$ is the \emph{soundness parameter}: the chances that a malicious Prover can fool the Verifier in a single attempt is $2^{-t}$. 

 For ease of description, we will also impose the following limitation on the $\Sigma$ protocols: in the interactive version, the verification code must proceed by computing $a'$ from $z$ and $e$, and then checking if $a'=a$. That means that in the noninteractive version, the Prover needs to transmit only $z$ and $e$ (omitting $a$) to the Verifier, who will compute $a'$ from $z$ and $e$ and then check that $e$ was computed correctly as a function of $a'$. If the hashing is second-preimage-resistant, an incorrect $a'$ will lead to a mismatch of $e$, which will be detected by the Verifier. This limitation is satisfied by most common $\Sigma$-protocols; it is not essential and can be removed by having the Prover additionally send $a$.

We show the steps of the prover and verifier given such a tree. While $\andnode$, $\ornode$, and $\tnode$ composition of $\Sigma$-protocols has been addressed in the literature before \cite{CDS94}, prover and verifier algorithms have been described only for a single node, in terms of prover, verifier, and simulator algorithms for its children. Recursively constructing code for an entire tree by dynamically constructing prover, verifier, and simulator code for each node is inefficient. Here we take a different approach by explicitly describing how and in what order the protocol messages for each node of the tree need to be computed and verified. We are not aware of any similar descriptions in the literature.

Our description uses two kinds of tree traversal: bottom-up (also known as post-order) and top-down (also known as preorder). In a bottom-up traversal, for each node, operations are recursively applied to the children of the node before being applied to the node itself. In a top-down traversal, for each node, operations are applied to the node itself before being recursively applied to each of its children.

\subsection{Proving}
\label{sec:proving}

The Prover will know secrets $w$ for some of the leaves; for such leaves, it will choose whether to produce real or simulated proofs according to the algorithm described in this section. The Prover will simulate proofs for all other leaves. 

Note that the algorithm described below does not attempt to be secure against side channel attacks, such as, for example, timing attacks. It particular, it may take different amounts of time depending on which nodes are real and which are simulated; a timing attacker may therefore obtain information about the set of leaves for which the Prover knows the secrets. If timing attacks are a concern, it is not enough to make sure that simulation and proving take a similar amount of time for each atomic $\Sigma$-protocol used in the leaves; implementations should also make sure that tree traversals take the same amount of time regardless of where simulated and real $\Sigma$ protocols are located in the tree. In particular, implementations should avoid the use of lazy-evaluation constructs, such as ``forall'' and ``exists''.


For each node in the tree, the prover will maintain a flag indicating whether it is real or simulated. Each node will also have a $t$-bit challenge. The leaves will additionally have two protocol values: a challenge and a response. The pseudocode below explains how these values are computed. In the psuedocode below, the word ``random'' should be read to also allow securely generated pseudorandom values.

The prover first has to decide which nodes will have real proofs (for which witnesses are required) and which will be simulated. For example, in an $\ornode$ proof, only one of the children will be real. The prover will do so based on witnesses that are available, in three steps:

\begin{enumerate}
    \item \label{step:initial-simulated} This step will mark as ``real'' every node for which the prover can produce a real proof. This step may mark as ``real'' more nodes than necessary if the prover has more than the minimal necessary number of witnesses (for example, more than one child of an $\ornode$).  This will be corrected in the next step. In a bottom-up traversal of the tree, do the following for each node:
        \begin{itemize}
            \item If the node is a leaf, mark it ``real'' if the witness for it is available; else mark it ``simulated''
            \item If the node is $\ornode$, mark it ``real'' if at least one child is marked real; else mark it ``simulated''
            \item If the node is $\andnode$, mark it ``real'' if all of its children are marked real; else mark it ``simulated''
            \item If the node is $\tnode(k)$, mark it ``real'' if at least $k$ of its children are marked real; else mark it ``simulated''
        \end{itemize}
    
    \item If the root of the tree is marked ``simulated'' then the prover does not have enough witnesses to perform the proof. Abort.
    
    \item This step will change some ``real'' nodes to ``simulated'' to make sure each node has the right number of simulated children.
          In a top-down traversal of the tree, do the following for each node:
        \begin{itemize}
            \item
            If the node is $\ornode$ marked ``real'',  mark all but one of its children ``simulated''
            (the node is guaranteed by step~\ref{step:initial-simulated} to have at least one ``real'' child).
            Which particular child is left ``real'' is not important for security; the choice can be guided by efficiency or convenience considerations.
            \item
            If  the node is $\tnode(k)$ marked ``real'', mark all but $k$ of its children ``simulated''
            (the node is guaranteed, by the previous step, to have at least $k$ ``real'' children).
            Which particular ones are left ``real'' is not important for security; the choice can be guided by efficiency or convenience considerations.
            \item
            If the node is marked ``simulated'', mark all of its children ``simulated''
        \end{itemize}
\end{enumerate}

\noindent
Now the prover will compute protocol values for every node, as follows:

\begin{enumerate}
\setcounter{enumi}{3}
    \item In a top-down traversal of the tree, compute the challenges $e$ for simulated children of every node, as follows:
    \begin{itemize}
        \item If the node is marked ``real'', then each of its simulated children gets  a fresh uniformly random challenge in $\{0,1\}^t$. (Note that a real $\andnode$ node has no simulated children, so this step applies only to real $\ornode$ and $\tnode$ nodes.)
        \item If the node is marked ``simulated'', let $e_0$ be the challenge computed for it.  All of its children are simulated, and thus we compute challenges for all of them, as follows:
        \begin{itemize}
            \item If the node is $\andnode$,  then all of its children get $e_0$ as the challenge
            \item If the node is $\ornode$, then each of its children except one gets a fresh uniformly random challenge in $\{0,1\}^t$. The remaining child gets a challenge computed as an XOR of the challenges of all the other children and $e_0$.
            \item If the node is $\tnode(k)$, assume it has $n$ children numbered from $1$ to $n$. There are two possible algorithms. The first algorithm is faster than the second. However, it is also faster than the algorithm for a ``real'' $\tnode$ node; therefore, if a timing attack on the prover is a possibility, then it should not be used, because the timing attack may be able to distinguish a ``real'' $\tnode$ node from a ``simulated'' one.
            \begin{enumerate} 
            	\item The faster algorithm is as follows. Pick  $n-k$ fresh uniformly random values $q_1, \dots, q_{n-k}$ from $\{0,1\}^t$ and let
	         $q_0=e_0$. Viewing $1, 2, \dots, n$ and $q_0, \dots, q_{n-k}$ as elements of $\GF(2^t)$, 
	         evaluate the polynomial $Q(x) = \sum {q_i x^i}$ over $\GF(2^t)$ at points $1, 2, \dots, n$
	         to get challenges for child $1, 2, \dots, n$, respectively.
	         \item The algorithm with better resistance to timing attacks is as follows. Pick $n-k$ fresh uniformly random values $e_1, \dots, e_{n-k}$
	         as challenges for the children number $1, \dots, n-k$.
	         Let $i_0 = 0$. Viewing $0, 1, 2, \dots, n$ and $e_0, \dots, e_{n-k}$ as elexments of $\GF(2^t)$, find (via polynomial interpolation) the
	          lowest-degree polynomial $Q(x)=\sum_{i=0}^{n-k} a_i x^i $ over $\GF(2^t)$ that is equal to $e_j$ at $j$ for each $j$ from
	          $0$ to $n-k$ (this polynomial will have $n-k+1$ coefficients, and the lowest coefficient will be $e_0$). Set the challenge at child
	          $j$ for $n-k<j\le n$ to equal $Q(j)$.
 	   \end{enumerate} 
        \end{itemize}
    \end{itemize}
    
    \item For every leaf marked ``simulated'', use the simulator of the $\Sigma$-protocol for that leaf to compute the commitment $a$ and the response $z$, given the challenge $e$ that is already stored in the leaf.
    
    \item For every leaf marked ``real'', use the first prover step of the $\Sigma$-protocol for that leaf to compute the necessary randomness and the commitment $a$.
    
    \item \label{step:fs}  Convert the tree to a string $s$ for input to the Fiat-Shamir hash function. The conversion should be such that the tree can be unambiguously parsed and restored given the string. For each non-leaf node, the string should contain its type ($\andnode$, $\ornode$, or $\tnode(k)$). For each leaf node, the string should contain the $\Sigma$-protocol statement being proven and the commitment. The string should not contain information on whether a node is marked ``real'' or ``simulated'', and should not contain challenges, responses, or the real/simulated flag for any node.
    
    \item Compute the challenge for the root of the tree as the Fiat-Shamir hash of $s$ (and, if applicable,  the associated data, such as the message being signed). 
    
    \item Perform a top-down traversal of only the portion of the tree marked ``real'' in order to compute the challenge $e$ for every node marked ``real'' below the root and, additionally, the response $z$ for every leaf marked ``real'' (note that nodes marked ``simulated'' have all their descendants marked ``simulated'' and all the challenges for these descendants already computed, so there is no need to recurse down ``simulated'' nodes, unless timing attacks are a concern). For every node, do the following:
    
    \begin{itemize}
        \item If the node is a non-leaf marked ``real'' whose challenge is $e_0$, proceed as follows:
    
        \begin{itemize}
            \item If the node is $\andnode$, let each of its children have the challenge $e_0$
            \item If the node is $\ornode$, it has only one child marked ``real''. Let this child have the challenge equal to the XOR of the challenges of all the other children and $e_0$
            \item If the node is $\tnode(k)$, number its children from $1$ to $n$. Let $i_1, \dots, i_{n-k}$ be the indices of the children marked ``simulated'' and $e_1, \dots,  e_{n-k}$ be their corresponding challenges. Let $i_0 = 0$. Viewing $0, 1, 2, \dots, n$ and $e_0, \dots, e_{n-k}$ as elements of $\GF(2^t)$, find (via polynomial interpolation) the lowest-degree polynomial $Q(x)=\sum_{i=0}^{n-k} a_i x^i $ over $\GF(2^t)$ that is equal to $e_j$ at $i_j$ for each $j$ from $0$ to $n-k$ (this polynomial will have $n-k+1$ coefficients, and the lowest coefficient will be $e_0$). For child number $i$ of the node, if the child is marked ``real'', compute its challenge as $Q(i)$ (if the child is marked ``simulated", its challenge is already $Q(i)$, by construction of $Q$).
        \end{itemize}
    
        \item If the node is a leaf marked ``real'', compute its response according to the second prover step of the $\Sigma$-protocol given the commitment, challenge, and witness
        
    \end{itemize}
    
    \item Output the proof consisting of the following information:
    \begin{itemize}
        \item The challenge of the root node
        \item For every $\ornode$ node: the challenges of all of its children but the rightmost
        \item For every $\tnode$ node: the coefficients $q_1 \dots q_{n-k}$ of the polynomial $Q(x)$ (excluding $a_0$)
        \item The responses for every leaf node
    \end{itemize}
\end{enumerate}

\subsection{Verifying}
\label{sec:verifying}


For each node in the tree, the verifier will obtain a $t$-bit challenge $e$ by either reading it directly from the proof or by using other information provided in the proof. For the leaves, the verifier will also read the response $z$ from the proof and will re-compute, using the challenge and the response, the commitment $a$.  Finally, verifier will hash the whole tree and will check that the hash value matches the challenge of the root node.

Note that, unlike the prover, the verifier has no way of knowing which nodes are real and which are simulated. In fact, making sure that the verifier cannot tell the difference between real and simulated nodes is one of the security goals of the protocol.

The pseudocode below details the verifier's steps.

\begin{enumerate}
\item Read the root challenge from in the proof. 

\item In a top-down traversal of the tree, obtain the challenges for the children of every non-leaf node by reading them from the proof or computing them, as follows. Let $e_0$ be the challenge in the node. 
        \begin{itemize}
            \item If the node is $\andnode$,  then all of its children get $e_0$ as the challenge
            \item If the node is $\ornode$, then each of its children except rightmost reads its challenge from the proof. The rightmost child gets a challenge computed as an XOR of the challenges of all the other children and $e_0$.
            \item If the node is $\tnode(k)$, let the number of its children be $n$. Assume the children are numbered from $1$ to $n$. Let $q_0=e_0$ and read the values $q_1, \dots, q_{n-k}$ from the proof. Viewing $1, 2, \dots, n$ and $q_0, \dots, q_{n-k}$ as elements of $\GF(2^t)$, evaluate the polynomial $Q(x) = \sum {q_i x^i}$ over $\GF(2^t)$ at points $1, 2, \dots, n$ to get challenges for child $1, 2, \dots, n$, respectively. 
        \end{itemize}
        
 \item For every leaf node, read the response $z$ provided in the proof.

\item For every leaf node, compute the commitment $a$ from the challenge $e$ and response $z$, per the verifier algorithm of the leaf's $\Sigma$-protocol. If the verifier algorithm of the $\Sigma$-protocol for any of the leaves rejects, then reject the entire proof.

\item Convert the tree to a string $s$ for input to the Fiat-Shamir hash function, using the same conversion as the prover in Step~\ref{step:fs}

\item Accept the proof if the challenge at the root of the tree is equal to the Fiat-Shamir hash of $s$ (and, if applicable,  the associated data). Reject otherwise.
\end{enumerate}

\section{Examples}

In this section we provide some examples of useful guarding scripts. We focus on examples which are impossible or much harder to express in Bitcoin Script.

\subsection{Crowdfunding}
\label{sec:crowdfunding}

We provide simple solution to crowdfunding here. In the example, a crowdfunding project associated with public key $x_P$ is considered successful if it can collect unspent outputs with total value not less than $to\_raise$ before height $timeout$. A project backer creates an output protected by the following statement: 

\begin{equation*}
\begin{split}
(height \ge timeout \land dlog(x_B)) \lor \\
(height & < timeout \land dlog(x_P)\\
& \land Exists(Outputs, 20,\\ 
& \quad \quad \quad \quad ExtractAmount(TaggedBox(20)) \ge to\_raise \land \\ 
& \quad \quad \quad \quad ExtractScriptBytes(TaggedBox(20)) = ToBytes(dlog(x_P))))
\end{split}
\end{equation*}

Then the project can collect biggest outputs with total value not less than $to\_raise$ with a single transaction~(it is possible to collect up to ~22,000 outputs in Bitcoin, which is enough even for a big crowdfunding campaign). For remaining small outputs over $to\_raise$, it is possible to construct follow-up transactions. 

Please note why such a guarding expression is not possible in Bitcoin: we use the condition on a spending transaction, namely, we require the transaction to have an output with value not less than required, and also with a particular statement protecting the output.

\subsection{Money With Scheduled Maintenance Payments}

\knote{description}

\begin{equation*}
\begin{split}
user\_statement \lor \\ 
(height & \ge (ExtractHeight(self) + period) \land \\
    & Exists(Outputs, 20, \\
    & \quad \quad \quad \quad ExtractAmount(TaggedBox(20)) \ge (ExtractAmount(self) - cost) \land \\ 
    & \quad \quad \quad \quad ExtractScriptBytes(TaggedBox(20)) = ExtractScriptBytes(self)))
\end{split}
\end{equation*}

We highlight impossibility of such a statement in the Bitcoin Script: similarly to the statement in the previous section~\ref{sec:crowdfunding}, we use a condition on a spending transaction. Another feature missed in the Bitcoin Script is that we also use an output to spend in the execution context. In particular, in the example above we require a spending transaction to have an output which has the same statement as an output it spends. 

\subsection{Ring Signature}
\label{sec:ring}

Linear-sized ring signature is very straightforward in the language. Assume a ring consists of $m$ public keys $x_1, \dots, x_m$. If one wants an output to be spent by a ring signature associated with the ring, the output is to be protected by the following statement:

$$dlog(x_1) \lor \dots \lor dlog(x_m)$$  

Please note that proving of the statement is to be done in zero-knowledge, so it is not possible to know which key signed, the only fact to conclude is that some key from the ring signed output spending. 

\subsection{Complex Signature Schemes}

We can build more complex signature schemes than possible in Bitcoin. One particular example was provided in the previous Section~\ref{sec:ring}. Another example is a scheme where at least one out of (Alice, Bob), and at least one out of (Charles, Diana) are needed to sign, and it is not to be known who signed an output spending. The corresponding statement involving public keys $x_A, x_B, x_C, x_D$ of Alice, Bob, Charles and Diana respectively would be following:

$$(dlog(x_A) \lor dlog(x_B)) \land (dlog(x_C) \lor dlog(x_D))$$

\subsection{Simple Tumbler}
\label{sec:tumbler}

\knote{does the example makes sense? check other tumbler papers. also, update the scripts, now approach is more generic than using tx.outbytes}

Privacy is a tough problem for cryptocurrency users. Bitcoin is a pseudonymous cryptocurrency, so no real identities attached to a transaction. However, it is possible to reconstruct transactional graph for all the transactions ever entered into the Bitcoin blockchain, and often restore real identities by using auxiliary databases. \knote{link} To improve privacy, tumblers are being used. A tumbler is a scheme which us getting some money transfers as inputs, produces output money transfers, and has a property of unlinkability: it is not possible to draw a link from an input to an output. Thus a tumbler user is hiding herself amongst a ring of users sending inputs to the scheme. Privacy then depends on a ring size. For maximum privacy, there exists a cryptocurrency ZCash with inbuilt tumbler based on zkSnarks\knote{links}, where a user is hiding among all the users in the system. However, ZCash requires trusted setup, and transaction validation is relatively slow~(10 ms). In other cryptocurrencies users are usually using external services varying in security and efficiency.

Here we are describing simple tumbler service. It is very efficient and requires no trusted dealer. Its disadvantage is that from observing blockchain transactions it is possible to conclude that users are using a tumbler.

Assume Alice with public key $x_A$ and Bob with public key $x_B$ want to relocate funds to keys $y_1$ and $y_2$ respectively, with a property than external observer looking into blockchain is not capable to know beyond the fact that money flows from $x_A$ to whether $y_1$ or $y_2$~(and the same for $x_B$).

First, Alice and Bob communicate off-chain to construct collectively outputs of the final transaction~(payments to $y_1$ and $y_2$). Each of them then is calculating a hash value from outputs bytes $h$~(we assume that Blake2b-256 hash function is used). Then each of them is creating an output to spend~(possibly, in a dedicated transaction) with such a condition for Alice and Bob, respectively:

$blake2b256(tx.outbytes) = h \lor dlog(x_A)$ 

$blake2b256(tx.outbytes) = h \lor dlog(x_B)$

Then it is possible to make a refund at any moment of time~(right condition in the $\lor$ conjectures), and before a refund any of the them can construct a transaction which is spending the outputs, and it is impossible to construct an alternative transaction, for which hash of the output bytes is $h$, but bytes are different~(if chosen hash function is collision-resistant).

\subsection{Oracle Example}

\knote{Text below is just copied from code comments, polish it}

A trusted weather station is publishing temperature data on blockchain. Alice and Bob are making a contract based on the data:
they have locked coins in such way that if output from the station shows that temperature announced by the oracle is > 15 degrees, money are going to Alice, otherwise to Bob.
    
We consider that for validating transaction only limited number of last headers and the spending transaction should be enough, in addition to outputs being spent by the transaction. Thus there is no need for knowledge of an arbitrary output. To show the coin of the weather service in the spending transaction, outputs from Alice and Bob are referencing to the coin by using Merkle proofs against UTXO set root hash of the latest known block.
    
A tricky moment is how Alice and Bob can be sure that a coin is indeed created by the service, having just the coin (and also service's public key x = $g^w$, where service's secret w is not known.
    
For that, we consider that the service creates a coin with registers of following semantics (R0 and R1 are standard):
    
R1 - coin amount
R2 - protecting script, which is the pubkey of the service, $x = g^w$
R3 - temperature data, number
R4 - $a = g^r$, where r is secret random nonce
R5 - $z = r + ew mod q$
R6 - timestamp
    
Then Alice and Bob are requiring from the coin that the following equation holds: $g^z = a * x^e$, where $e = hash(R3 ++ R6)$
    
Thus Alice, for example, is created a coin with the following statement (we skip timeouts for simplicity):
"the coin is spendable by presenting a proof of Alice's private key knowledge if against UTXO set root hash for
the last known block there is a coin along with a Merkle proof, for which following requirements hold:
$R2 = dlog(x) /\ g^(R5) = R4 * x^(hash(R3 ++ R6)) /\ (R3) > 15$. Similarly, the coin is spendable by a proof of
knowledge of the Bob's private key if all the same conditions are met but $(R3) <= 15$.".
    
The Bob can create a box with the same guarding conditions. However, if Alice's box is already in the state, then Bob can stick to it by using the trick from the "along with a brother" test.


\section{Safety Guarantees}
\label{sec:safety}

We need to be sure that an adversary can not produce such a statement for
which the Verifier spends more time than it is safe to spend. \knote{links to
verifier dilemma, orphan rates etc}

In order to filter out malicious statements, Verifier needs to perform a
series of safety checks in particular consistency checks and cost
estimations. This safety checks by itself require Verifier to spend some
time. However, the idea is to strictly limit the check complexity to be
linear in the size of the statement tree and input data, which are strictly
limited in size.

Verification and safety checks are performed in stages.

\subsection{Verification and Safety Checks}
\label{sec:safety-checks}

Verifier performs the following safety checks:

\begin{enumerate}
\item \textbf{Deserialization of Statement.}
Verifier receives the statement as an array of bytes and checks that the size
of array is less than predefined constant $C_1$. Deserializer parses the
array of bytes and checks if it is according to the format. Deserializer also
controls the size of the constructed statement tree. It should be less than
predefined constant $C_2$. The tree being constricted is also checked to
satisfy typing rules. After deserialization stage we have valid tree of known
limited size $TreeSize$. We want the complexity of all subsequent checks to
be $O(TreeSize)$.

\item \textbf{Instantiation of the Cost Function.}
Cost Function is the function of the same input (Context, variables,
registers, etc.) as Statement function, but it computes Long value of the
computation cost of the Statement function, so it answer the question "How
many operations it is required to compute the statement?". 

The Cost Function is instantiated by the following steps:
    \begin{enumerate}
        \item Cost Function Tree, CFT, is obtained by:
        \begin{itemize}
            \item reading from the bytes stream immediately after Statement
            Tree. In this case the CFT is integral part of the Statement.
            \item generating from Statement Tree using algorithm $genCFT$
        \end{itemize}
        Both of these cases provide equivalent guarantees and only differ by
        the time of CFT generatation
        \item After the CFT is obtained the standard interpreter is used to
        evaluate it and calculate an estimation of the computation cost of
        the Statement. (Section \ref{sec:gen-cost-function})
    \end{enumerate}

 The idea is that the complexity of the Cost Function is linear in the size
 of the Statement tree in most of the cases. In the worst case it is linear
 in the size of the input data of the Statement which is strictly limited in
 size.
 We also rely on the fact that the complexity of $genCFT$ is linear in the
 size of the Statement Tree.

\item \textbf{Evaluating the Statement cost.}
The Cost Function is applied immediately before evaluation of the Statement
by the following steps: 
    \begin{enumerate}
        \item construct the context as it is required for Statement evaluation 
        \item invoke the interpreter to evaluate the Cost Function Tree in the
        given context
    \end{enumerate}

The generation of the CFT is further described in
section~\ref{sec:gen-cost-function}. Upon computing the cost of Statement
using Cost Function the Verifier check that it is less than the predefined
constant $C_3$.
\end{enumerate}

Passing all three stages of safety checks above, the Verifier is safe to
evaluate the Statement tree in a current data context. This Statement
evaluation is guaranteed to terminate in the estimated amount of time.

\subsection{Generation of Cost Function Tree}
\label{sec:gen-cost-function}

Here we briefly describe an algorithm $genCF$ to construct a Cost Function
tree. The basic idea is that we perform single traversal of the Statement
tree, visiting all the nodes from leaves up to the root. During traversal
foreach Statement node $t$ with children ${c_1 \dots c_k}$ we
construct$genCF(t)$ using ${genCF(c_1) \dots genCF(c_n)}$. Algorithm $genCF$
is defined recursively over the tree structure as shown in
Figure~\ref{fig:genCFT}. In the figure $dataCost(v)$ is a function to compute
a cost of the evaluated value $v$ represented either by $ContextVar$ of
$Constant$ tree nodes.

\begin{figure}
\begin{center}
\begin{tabular}{>{$}l<{$} >{$}c<{$} >{$}l<{$}} 
    \multicolumn{3}{@{}l}{\textbf{def} $genCF(D: Context, t: Value[T]): Value[Long]$}  \\
    D, v~@~ContextVar(\_) & \to & dataCost(v) \\
    D, c~@~Constant(\_) & \to & dataCost(c) \\
    D, t_1 \otimes t_2 & \to & genCF(D, t_1) + Cost_\otimes + genCF(D, t_2) \\
    arr.map(f) & \to & 
        \begin{tabular}[t]{l}
            let $f_{cost}$ = $genCF(D, f)$ \\
            $sum(arr.map(\lambda x \to f_{cost}(x)))$ \\
        \end{tabular} \\
     & \to & $\mnote{arg}$ \\
    % v @ Constant(_) & \to & 
    %     \begin{tabular}[t]{l}
    %         $v :=$ variable with $varId$ from data environment \\
    %         return $dataCost(v)$ \\
    %     \end{tabular} \\
\end{tabular}
\caption{Algorithm $genCFT$}
\label{fig:genCFT}
\end{center}
\end{figure}

\subsection{Storing Cost Function}
\label{sec:store-cost-function}


\subsection{Cost Interpreter}
\label{sec:cost-interpreter}



\subsection{Cost Model}
\label{sec:cost-model}



\subsection{Denial-of-Service Attacks}


\section{Extensibility}

It is hard to predict which functions would be useful for blockchain applications.

\section{Implementation and Evaluation}

\section{Further Work}

\section{Conclusion}

We show in this paper...




\bibliographystyle{alpha}
\bibliography{sigma.bib}



\appendix

\section{Open Questions}

\begin{enumerate}
  \item Q: Let's use $\lor$, $\land$ for logical connectives, and $\sqcup$, $\sqcap$ for
           sigma-connectives correspondingly? \linebreak
        A:
  \item Q: Do we have "knowledge of Pedersen commitment $x_2$ preimage" somehow implemented? \linebreak
        A:
  \item Q: What are the limitations of ErgoScript? \linebreak
        A: The following are the constraint of current implementation of ErgoScript:
        \begin{itemize}
          \item Let bound expressions are copied in every usage site during compilation. This leads to repeated evaluation of the corresponding expressions.
          \item Lambdas are not first-class. After compilation all Lamdas should be inlined.
          \item Nested collections are not supported
        \end{itemize}
\end{enumerate}

\section{Types}

\[\begin{tabular}{@{}l c l l}
      $\mathcal{T} \ni \tau$			& ::= 	    &\
         \lst{Byte} $\mid$ \lst{Short} $\mid$
         \lst{Int} $\mid$ \lst{Long} $\mid$ \lst{BigInt}  & numeric types     \\
      &	$\mid$	& \lst{Boolean} 			& type of logical values true/false   \\
      &	$\mid$	& \lst{Unit} 				& type with single element   \\
      &	$\mid$	& \lst{GroupElement} 		& element of the cryptographic group  \\
      &	$\mid$	& \lst{Box} 				& value in a box protected by proposition  \\
      &	$\mid$	& \lst{AvlTree} 			&  Authenticated Dynamic Dictionary \\
      &	$\mid$	& $(\tau_1, \dots, \tau_n) $	& binary product type  \\
      & $\mid$  & $\text{\lst{Array}}[\tau]$	& array type       \\
      & $\mid$  & $\text{\lst{Option}}[\tau]$	& optional value (either $Some(\tau)$ or $None$)      \\
      & $\mid$  & \lst{Any}                     & type of any value (common supertype of all the types) \\
\end{tabular}\]

\section{Tree Nodes and Transformation Rules}

\section{Cost Table}

\section{Roadmap}

\section{Outputs vs Accounts}

\section{Unified Transactions}
\label{apx:unified}

\section{An Example of a Concrete Transaction Format}
\label{apx:tx-format}

\knote{Describe Ergo transaction format here. Malleability problems to be discussed here.}

\section{A Language For An Account-Based Cryptocurrency}
\label{apx:account}



\end{document}